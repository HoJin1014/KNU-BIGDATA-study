HTML/CSS
웹사이트 만들기

웹을 구성하는 요소

프로그래밍이란?
컴퓨터와 소통하는 방법을 의미 <- 코드
컴퓨터에게 전달하는 정보를 어떻게 보여주고 제어할지 결정 가능 <- 웹 프로그래밍
웹 개발을 하기 위한 언어로 브라우저와 소통 - Chrome, Internet Explorer

HTML - 정보 또는 설계도 (글, 이미지)
CSS - 디자인 또는 스타일링 (style sheet)
JabaScript - 기능과 효과

웹사이트 제작 = 건물 짓기

HTML - 건물 설계도
CSS - 인테리어 디자인
JavaScript - 기능과 효과 ex) 엘리베이터
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
-HTML 문서를 구성하는 태그-
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
</head>
<body>
    <!-- 아래 코드를 완성하고 제출 버튼을 눌러보세요! -->
    <h1 style="color:navy">안녕 엘리스!</h1>
</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
-HTML 기본 태그- 
여러 태그로 구성
Hyper Text Markup Language
웹사이트에서 눈에 보이는 '정보'나 특정 '구역'을 설정할 때 사용하는 언어

HTML의 변화 - 시간이 지남에 따라 자주 사용되지 않는 용어들은 사라지고 시대에 맞추어 새로운 신조어가 등장
현재 HTML5

-HTML 태그 구성 요소-
Example - <열린태그 속성 = "속성값"> 컨텐츠 </닫힌태그>

태그명 - HTML이 갖고 있는 고유의 기능 <열린태그></닫힌태그>형태로 입력
컨텐츠 - 열린 태그와 닫힌 태그 사이에 있는 내용물

-HTML 태그 구성 요소-
Example - <열린태그 속성 = "속성값"> 컨텐츠 </닫힌태그>
속성 - HTML 태그가 갖고 있는 추가정보
속성값 - 어떤 역할을 수행할지 구체적인 명령을 진행하는 것

-HTML 문서의 기본 구조-
<!DOCTYPE html>                                      <!DOCTYPE html>
<html>                                                   HTML5라는 신조어로 문서를 선언하는 태그
<head>
     <meta charset="UTF-8">                        <html>...</html>
     <title>웹프로그래밍</title>                  HTML 문서의 시작과 끝을 의미
</head>                                                 모든 HTML 태그들은 <html>태그 안쪽에 입력
<body>                                                 
</body>                                                   <head>...</head>
</html>                                               웹사이트의 간단한 요약 정보를 담는 영역, 노출되지 않는 정보
                                                  
                                                              <body>...</body>
                                                            웹사이트에서 눈에 보이는 정보를 담는 영역
                                                            이미지나 텍스트처럼 출력되는 정보

                                                             <meta charset="UTF-8">
                                                           character setting의 약자를 나타내는 문자코드
                                                            모든 문자를 웹 브라우저에서 깨짐 없이 표시하겠다는 의미

                                                             <title>...</title>
                                                            웹사이트 탭에 나타나는 제목을 적는 태그


<a>태그
Example - <a hred = "https://www.naver.com" target = "_blank> 네이버 </a>

<a>...</a>
글자나 이미지 클릭시 다른 사이트로 이동시키는 태그
열린 태그와 닫힌 태그 사이에 컨텐츠 입력

href 속성
HTML 연결할 페이지의 주소 지정

target 속성
어떤 방식으로 페이지로 이동할지 결정

"_blank"
새 탭을 띄워서 웹사이트를 전환

"_self"
현재 탭에서 웹사이트를 전환 (디폴트 값)

<img> 태그
Example - <img src="logo.png" alt="회사로고">

<img> 태그
정보성을 갖고 있는 이미지를 삽입. 닫힌 태그 없음.

src 속성
삽입할 이미지 파일 경로

alt 속성
웹사이트가 이미지를 출력하지 못했을 경우, 텍스트 정보로 대체

<h>태그
Example
<h1>Hello World</h1>
<h2>Hello World</h2>
<h3>Hello World</h3>
Heading의 약자로 제목이나 부제목을 표현
숫자 값이 클수록 폰트 사이즈가 작음. 즉, 숫자는 정보의 중요도를 나타냄
<h1>태그는 가장 중요한 정보를 담으므로, 하나의 html 문서에서 한 번만 사용됨

<p> 태그
Example - <p>Nice to meet you</p>
Paragraph의 약자로 본문 내용을 표현
웹사이트의 중요 정보를 담는 태그
나타내고자 하는 내용을 열린 태그와 닫힌 태그 사이에 입력


<ol>, <li>태그
Example
<ol>
    <li>메뉴1</li>             -               1. 메뉴1
    <li>메뉴2</li>             -               2. 메뉴2
    <li>메뉴3</li>             -               3. 메뉴3
</ol>

<ol> 태그
Ordered list의 약자로, 순서가 있는 리스트 생성


<li> 태그
<ol>과 <ul>의 각 항목을 나열할 때 사용

<ul> 태그
Example
<ul>
    <li>메뉴1</li>             -               . 메뉴1
    <li>메뉴2</li>             -               . 메뉴2
    <li>메뉴3</li>             -               . 메뉴3
</ul>

<ul> 태그
Unordered list의 약자로, 순서가 없는 리스트 생성
메뉴 버튼을 만들 때 사용되는 태그
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
링크와 이미지 입력하기
href – 연결할 웹페이지의 URL 주소
target – 웹페이지를 연결하는 방식
src – 입력하고자 하는 이미지 파일
alt – 이미지를 대신하는 설명

<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>엘리스 :: elice</title>
</head>
<body>
    <!-- 지시사항을 따라 아래에 코드를 작성하고 제출 버튼을 눌러보세요! -->
    <a href="https://www.naver.com" target="_blank">네이버</a>
    <img src="elice_logo.png" alt="엘리스 회사 로고">
</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
h 태그 입력하기
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>엘리스 :: elice</title>
</head>
<body>
  <!--1. h1 태그를 이용해 Hello Elice를 입력합니다.-->
  <h1>Hello Elice</h1>
  
  <!--2. h2 태그를 이용해 Hello Elice를 입력합니다.-->
  <h2>Hello Elice</h2>
  
  <!--3. h3 태그를 이용해 Hello Elice를 입력합니다.-->
  <h3>Hello Elice</h3>
  
  <!--4. h4 태그를 이용해 Hello Elice를 입력합니다.-->
  <h4>Hello Elice</h4>
  
  <!--5. h5 태그를 이용해 Hello Elice를 입력합니다.-->
  <h5>Hello Elice</h5>
  
  <!--6. h6 태그를 이용해 Hello Elice를 입력합니다.-->
  <h6>Hello Elice</h6>
  
</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
텍스트 입력하기
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>엘리스 :: elice</title>
</head>
<body>
  <!--1. p 태그를 이용해 동해물과 백두산이 마르고 닳도록...을 입력합니다.-->
<p>동해물과 백두산이 마르고 닳도록...</p>
  
  <!--2. <ol> 태그 안에 <li>메뉴</li>를 입력합니다.-->
<ol> 
````<li>메뉴1</li>
    <li>메뉴2</li>
    <li>메뉴3</li>
</ol>
  
  <!--3. <ul> 태그 안에 <li>메뉴</li>를 입력합니다.-->
<ul> 
    <li>메뉴1</li>
    <li>메뉴2</li>
    <li>메뉴3</li>
</ul> 
  
  <!--4. 홈, 회사 소개, 연락처를 나타내는 메뉴 버튼을 <ul>과 <li> 태그를 이용해 만들어봅니다.-->
<ul> 
    <li><a href="#">홈</a></li>
    <li><a href="#">회사 소개</a></li>
    <li><a href="#">연락처</a></li>
</ul>  
  
</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
-구조를 잡을 때 사용하는 태그-

책의 구조
목차 - 본문 - 부록 (기승전결) - 웹사이트 또한 동일한 구조

목차 - logo, 선택 요소

본문 - 대상이 메인으로 담김 - 어떤 내용 확인, 확장

부록 - 사업자 등록 번호, 언어, 연락 수단, 이메일

<header>, <nav>태그                                             <header> 태그
Example                                                                웹사이트의 머리글을 담는 공간
<header>   <! -- 상단 영역 -->
 <nav>       <! -- 메뉴 영역 -->                                 <nav> 태그 - 홈, 수업, 설정
   ...                                                                       메뉴 버튼을 담는 공간
  </nav>                                                                <ul>,<li>,<a>와 함께 사용
</header>                                                                


<header>, <nav> 태그
Example
<header>   <! -- 상단 영역 -->
   <img src = "elice_logo.png" alt="엘리스 로고">
   <nav>     <! -- 메뉴 버튼 영역 -->
         <ul>
             <li>홈</li>
             <li>전체 목록</li>
         </ul>
    </nav>
</header>


<main>, <article> 태그
<main>                                            <article>


<main>  태그
          <main role="main><!-- 본문 영역 -->
                 <article>      <!-- 정보 영역 -->
                 ...
                  </article>
           </main>

문서의 주요 내용을 담는 태그, IE는 지원하지 않으므로 role="main" 속성 필수 입력


<article> 태그
<main role ="main"><!-- 본문 영역 -->
   <article>      <!-- 정보 영역 -->
   ...
   </article>
</main>

문서의 주요 이미지나 텍스트 등의 정보를 담고 구역을 설정하는 태그,
태그 내에 구역을 대표하는 타이틀 <h> 태그가 존재해야 함


<footer> 태그
가장 하단에 들어가는 정보를 표기할 때 사용

<div> 태그
임의의 공간을 만들 때 사용

Example
<footer> <! --하단 영역-->
 <div> <!-- 엘리스 정보 -->
       <p>주소: 대전광역시 유성구 문지로 193 KAIST</p>
       <p>이메일: contact@elice.io</p>
 </div>
 <div>    <!-- 전자상거래 소비자보호법 필수 정보 -->
       <p>사업자등록번호   </p>
       <p>통신판매신고번호</p>
 </div>
</footer>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
공간을 만들 때 사용하는 태그
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>엘리스 :: elice</title>
</head>
<body>
  <!--상단 영역 <header>-->
  <header>
    <!--지시사항 1번의 내용을 기입합니다.-->
  <h1>
    <img src="elice_logo.png">
  </h1>
    <!--지시사항 2번의 내용을 기입합니다.-->
<nav>
<li><a href="#">홈</a></li>
<li><a href="#">회사 소개</a></li>
<li><a href="#">연락처</a></li>
</nav>
  </header>
  
  <!--본문 영역 <main>-->
  <main role="main">
    <article>
      <!--지시사항 1번의 내용을 기입합니다.-->
      <h2>회사 소개</h2>
      <!--지시사항 2번의 내용을 기입합니다.-->
      <p>회사 소개와 관련된 본문 내용</p>
    </article>
  </main>
  
  <!--하단 영역 <footer>-->
  <footer>
    <!--지시사항 1, 2, 3번의 내용을 기입합니다.-->
    <div>
        <p>서울시 서초구</p>
    </div>
    <div>
        <p>010-111-2222</p>
    </div>
    
  </footer>
</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
HTML 태그의 두 가지 성격

Block 요소와 Inline 요소

<!-- Block 요소 -->
<p>Hello Elice</p>
<p>Hello Elice</p>
<p>Hello Elice</p>

<!-- Inline 요소 -->
<a>Bye Elice</a>
<a>Bye Elice</a>
<a>Bye Elice</a>

두 요소를 구분 짓는 세 가지 주요 특징: 줄바꿈 현상, 가로.세로, 상.하 배치

-Block 요소-
y축 정렬 형태로 출력 (줄바꿈 현상 나타남), 공간을 만들 수 있고, 상하 배치 작업 가능

-Inline 요소-
x축 정렬 형태로 출력(한 줄에 출력), 공간을 만들 수 없고, 상하 배치 작업 불가능
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
화면을 만들어 주세요!
코더랜드 사이트에 이번에는 엘리스 모자장수가 방문한다고 합니다. 
모자장수를 위해 웹페이지를 만들어 주세요! 
웹페이지 구성을 만들기 위해 html을 활용할 수 있습니다. 
지시사항에 따라 html 코드를 작성해 주세요.

지시사항
주어진 index.html 파일에는 총 4개의 태그가 누락되어 있습니다. 아래에 제시된 부모, 자식 관계를 파악하여 index.html 파일에 4개의 태그를 알맞게 입력해 주세요.

<ul></ul> 태그

<header></header> 태그의 자식입니다.
<li></li> 태그의 부모입니다.
<div></div> 태그

<main></main> 태그의 자식입니다.
<h2></h2> 태그의 부모입니다.
<a></a> 태그

<main></main> 태그의 자식입니다.
<div></div> 태그의 형제 (sibling)입니다.
<img> 태그의 부모입니다.
href 속성값은 '#'입니다.
<img> 태그

<a></a> 태그의 자식입니다.
src 속성값은 'rabbit.png' 입니다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
<!--문제의 지시사항에 따라 총 4개의 태그를 추가해 주세요-->

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>엘리스 코더랜드</title>
    <link rel="stylesheet" href="index.css" />
  </head>
  <body>
    <header class="intro">
<ul>      
      <li>이곳은 코더랜드입니다!</li>
</ul>    
    </header>
    <main class="main">
<a>
<div>      
      <h2>코더랜드에서 멋진 프로그래밍 여행을 시작해 보세요.</h2>
</div>
<img src="rabbit.png">
</a>    
    </main>
  </body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
CSS - 웹사이트의 디자인

CSS란? Cascading Style Sheet
- 정보(HTML)와 디자인(CSS)의 분리
- 문서의 레이아웃과 스타일 정의
- HTML로 작성된 정보를 꾸며주는 언어

CSS 구성요소
선택자 { 속성 : 속성값; }

선택자 - 디자인을 적용할 HTML 영역
속성 - 어떤 디자인을 적용할지 정의
속성값 - 어떤 역할을 수행할지 구체적으로 명령. 세미클론(;) 필수 입력

속성 Property
  h1 {                                          /*           
선택자
     font_size: 20px;                       폰트 사이즈
     font-family: sans-serif;              글꼴
     color: blue;                             폰트 색깔
     background-color: yellow;         배경색
     text-align: center;                    텍스트 정렬
          속성     속성값
     }
                                                 /*

-Inline Style Sheet-
<h1 style-"color: red;"> coding 101 </h1>
태그 안에 직접 원하는 스타일을 적용

-Internal Style Sheet-
<head>
<style>
    h1 { background-color: yellow; }
</style>
</head>

-External Style Sheet-
<head>
   <link rel="stylesheet" href="style.css">
</head>
링크 태그로 불러오기

External Style Sheet
<h1> 엘리스 수업 </h1>                         h1 {
<h2> 코딩유치원 </h2>                             font-style: italic;
<p> 쉽고 재미있는 파이썬                        }
입문 수업!</p>

- html, css 각각의 문서 안에서 따로 관리하여 상대적으로 가독성이 높고 유지보수가 쉬움
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
CSS 연동 방법
CSS를 연동하는 방법으로는 세 가지가 있습니다. 세 방법으로 CSS를 연동해보고, 차이를 알아봅시다!

Internal Style Sheet – <style> 태그 안에 CSS 코드를 작성합니다.

<head>
    <style>
        h1 { color: blue; }
    </style>
</head>

<body>
    <h1>Hello World</h1>
</body>
Copy

지시사항
<head></head> 태그 안에 <style></style> 태그를 입력합니다. 그 안에 h1 {color:red;}를 입력하고 실행 결과를 확인해보세요.
<style>
  h1 {
      color:red;
  }
</style>
Copy
Tips
속성값을 입력할 때 ;를 잊지 말고 넣어주세요!

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>CSS 연동 방법</title>
  <!--지시사항 1번에 내용을 코드로 작성해보세요.-->
<style>
  h1 {
      color:red;
  }
</style>  
  
</head>
<body>
  <h1>Hello world</h1>
</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
CSS 연동 방법
CSS를 연동하는 방법으로는 세 가지가 있습니다. 세 방법으로 CSS를 연동해보고, 차이를 알아봅시다!

External Style Sheet – <link> 태그로 CSS 문서를 불러옵니다.

<!-- html 문서 -->
<head>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <h1>Hello World</h1>
</body>
Copy
/* css 문서 */
h1 { color: blue; }
Copy

지시사항
<head></head> 태그 안에 <link rel="stylesheet" href="index.css"> 입력하여 css 파일을 연동시킨 후 실행해보세요. index.css파일 내용과 함께 실행 결과를 확인해보세요!
<link rel="stylesheet" href="index.css">

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>CSS 연동 방법</title>
  <!--지시사항 1번에 내용을 코드로 작성해보세요.-->
<link rel="stylesheet" href="index.css">  
  
</head>
<body>
  <h1>Hello world</h1>
</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
CSS 연동 방법
CSS를 연동하는 방법으로는 세 가지가 있습니다. 세 방법으로 CSS를 연동해보고, 차이를 알아봅시다!

Inline Style Sheet – 태그 안에 직접 원하는 스타일을 적용합니다.

<body>
    <h1 style="color: blue;">Hello World</h1>
</body>
Copy

지시사항
<body></body> 태그 안에 있는 열린 태그 <h1> 에 style="color:blue;"를 입력하고 실행 결과를 이전 값과 비교해보세요.
<h1 style ="color: blue;">Hello World</h1>

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>CSS 연동 방법</title>
  
  <link rel="stylesheet" href="index.css">
</head>
<body>
  <!--지시사항 1번에 따라 <h1> 태그를 수정해보세요.-->
  <h1 style = "color: blue;">Hello world</h1>
  
</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
CSS 선택자

선택자(Selector) -HTML의 어떤 요소에 CSS를 적용할 것인가?

Type 타입
Class 클래스
ID 아이디

Type Selector - 특정 태그에 스타일을 적용

//<h2> Type Hello World </h2>
<style>
h2 { color: red; }
</style>

-Class Selector- 클래스 이름으로 특정 위치에 스타일을 적용
//<h2 class="coding"> Class Hello World </h2>
<style>
.coding { color: blue; }
</style>


-ID Selector- ID를 이용하여 스타일을 적용
// <h2 id="coding"> ID Hello World </h2>

 <style>
 # coding { color: green; }
 </style>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
CSS 선택자
CSS 선택자로는 세 가지가 있습니다. 세 선택자를 사용해 각각의 태그에 CSS 속성을 적용해봅시다!
Type 선택자 – 특정 태그에 스타일을 적용합니다.

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>CSS 선택자</title>
  <!--지시사항 2번을 따라 CSS 선택자를 적용해 Style을 부여해보세요.-->
<style>
    h2 {
        color: red;
    }
</style>  
  

</head>
<body>
  <!--지시사항 1번을 따라 <body> 태그 안에 내용을 작성해보세요.-->
<h2>Type Hello World</h2>
<h2 class="coding">Class Hello World</h2>
<h2 id="coding">Id Hello World</h2>
</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
CSS 선택자
CSS 선택자로는 세 가지가 있습니다. 세 선택자를 사용해 각각의 태그에 CSS 속성을 적용해봅시다!
Class 선택자 – .으로 클래스 이름을 선언하고, 해당 클래스에 스타일을 적용합니다.

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>CSS 선택자</title>
  
  <style>
    h2 {
      color: red;
    }
    /* 지시사항 1번을 따라 CSS 선택자를 적용해 Style을 부여해보세요. */
.coding {
  color: green;
}    
    
  </style>
</head>
<body>
  <h2>Type Hello World</h2>
  <h2 class="coding">Class Hello World</h2>
  <h2 id="coding">Id Hello World</h2>
</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
CSS 선택자
CSS 선택자로는 세 가지가 있습니다. 세 선택자를 사용해 각각의 태그에 CSS 속성을 적용해봅시다!
ID 선택자 – #으로 ID를 선언하고, 해당 ID에 스타일을 적용합니다.

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>CSS 선택자</title>
  
  <style>
    h2 {
      color: red;
    }
    .coding {
      color: green;
    }
    /* 지시사항 1번을 따라 CSS 선택자를 적용해 Style을 부여해보세요. */
#coding {
  color: yellow;
}    
  </style>
</head>
<body>
  <h2>Type Hello World</h2>
  <h2 class="coding">Class Hello World</h2>
  <h2 id="coding">Id Hello World</h2>
</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
-부모 자식 관계1-
<header>                                            // style.css 문서
   <h1>Header h1</h1>                       header { color: red; }
   <p>Header p</p>                            h1 { color: blue; }
</header>                                          p { color: green; }

<header>과 <h1><p>: 부모 자식 관계
 <h1>과<p>: 형제 관계

-부모 자식 관계2-
<header>                                            // style.css 문서
   <h1>Header h1</h1>                       header { color: red; }
   <p>Header p</p>                            h1 { color: blue; }
</header>                                          p { color: green; }
<footer>
   <h1>Footer h1</h1>
   <p>Footer p</p>
</footer>

원하는 지역에만 css 속성을 적용하기 위해 부모를 구체적으로 표기
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
CSS 속성의 상속
부모 태그 <header> <footer>의 CSS 속성은 자식 태그 <h1> <p>가 상속 받습니다.

반대로 자식 태그의 CSS 속성은 부모 태그에 영향을 미치지 않습니다.

각 태그의 속성값을 바꿔보며 CSS 속성의 상속에 대해 알아봅시다!

지시사항
<body> 태그 안에 <header> 태그와 <footer> 태그를 입력합니다. 두 태그는 <h2> 태그와 <p> 태그를 자식 태그로 갖습니다.
<style> 태그 안에서 부모 태그와 자식 태그의 CSS 속성을 설정해보며, 속성의 상속에 대해 알아봅니다.





ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
캐스케이딩
CSS의 우선순위를 결정하는 세 가지 요소
순서 - 디테일 - 선택자

순서에 의한 캐스케이딩
<p>Hello World</p>

// style.css 문서
p { color: red; }
p { color: blue; }


디테일에 의한 캐스케이딩 - 더 구체적으로 작성된 선택자의 우선순위가 높음
<header>                                  // style.css 문서
   <p>Hello World</p>               header p { colorL red; }
</header>                                 p { color: blue; }


선택자에 의한 캐스케이딩 - style > id > class > type 순으로 우선순위가 높음
   <h3 style="color: pink" id="color" class="color"> color </h3>
   // style.css 문서
   #color { color: blue; }
   .color { color: red; }
   h3 { color: green; }
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
CSS 캐스케이딩
CSS의 우선 순위를 결정하는 요소는 다음 세 가지입니다.

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>CSS 우선 순위</title>
  <!--지시사항 2번 내용을 코드로 작성해보세요.-->
<style>
    p {
        color: blue;
    }

    header h3 {
        background-color: green;
    }
</style>  
  
</head>
<body>
  <!--지시사항 1번 내용을 코드로 작성해보세요.-->
<p>순서 캐스케이딩</p>

<header>
    <h3>디테일 캐스케이딩</h3>
</header>

<h4 style = "color: green;" id="color" class="color">선택자 캐스케이딩</h4>  
  
</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
width, height

<p class = "paragraph"> 프로그래밍을 배워봐요! </p>

.paragraph { width: 500px; height: 500[x; }

-width속성-
선택한 요소의 너비를 설정
픽셀(px), 퍼센트(%)

-height속성-
선택한 요소의 높이를 설정


font
<p class="paragraph"> 즐거운 웹프로그래밍!</p>

.paragraph {
	font-size: 50px;	/* 글자크기 */
	font-family: Arial, sans-serif;	/* 글꼴 */
	font-style: italic;	/* 글자 기울기 */
	font-weight: bold;	/* 글자 두께 */
            }


font-family
브라우저마다 지원하는 폰트가 다름.
입력한 순서대로 우선순위 적용.
sans-serif는 마지막에 작성하는 디폴트 값.

font-weight
100~900 사이의 숫자를 입력할 수도 있음.


border
<p class="paragraph"> 즐거운 웹프로그래밍!</p>

.paragraph {
	width: 500px;
	height: 500px;
	border-style: solid;
	border-width: 10px;
	border-color: red;
	/* border: solid 10px red; */
            }

border-style
실선: solid
점선: dotted

주석과 같이 한 줄에 이어 쓸 수도 있음, 이때 쉼표는 작성하지 않고 띄어쓰기만 함.


background
<p class="paragraph"> 즐거운 웹프로그래밍!</p>

.paragraph {
	background-color: yellow;
	background-image: url(이미지경로);
	background-repeat: no-repeat;
	background-position: left;
	/* background: yellow url(이미지 경로)
		        no-repeat left; */
            }


background-repeat
x축으로 반복: repeat-x
y축으로 반복: repeat-y
반복하지 않음: no-repeat

background-position
공간 안에서 이미지의 좌표를 변경할 때
top, bottom, center, left, right 등
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
CSS 주요 속성 1
width, height – 요소의 넓이와 높이를 설정합니다.
.paragraph { 
    width: 500px; 
    height: 500px; 
}
Copy
font- – 글자 크기, 글꼴, 두께 등, 글자와 관련된 속성을 설정합니다.
.paragraph { 
    font-size: 50px;
    font-family: Arial, sans-serif;
    font-style: italic;
    font-weight: bold;
}
Copy
<body> 안에서 <h1>를 사용해 Nice to meet you를 출력합니다.
<style> 태그 안에서 클래스 이름을 호출하고, .paragraph의 넓이, 높이, 배경색, 그리고 글자 속성을 결정합니다.
width, height, background-color, font- 속성을 이용해 .paragraph 클래스의 넓이와 높이, 배경색 그리고 글꼴을 설정해봅시다!


<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>CSS 주요 속성 1</title>
  
  <style>
    .paragraph {
    /* 지시사항 1번 내용을 코드로 작성해보세요. */
width: 500px; 
height: 500px;    
    /* 지시사항 2번 내용을 코드로 작성해보세요. */
background-color: green;    
    /* 지시사항 3번 내용을 코드로 작성해보세요. */
font-size: 50px;
font-family: Times, Arial, sans-serif;
font-style: italic;
font-weight: bold;    
    }
  </style>
  
</head>
<body>
  
  <h1 class="paragraph">Nice to meet you</h1>
  
</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
CSS 주요 속성 2
지시사항
테두리는 실선(solid) 형태로, 두께는 2px, 색상은 빨간색으로 설정합니다.
border-style: solid;
border-width: 2px;
border-color: red;
Copy
배경색은 노란색으로, 배경 이미지는 엘리스 로고(elice_logo.png) 그림으로, 이미지 반복 없이(no-repeat), 가운데(center) 정렬로 설정합니다.
background-color: yellow;
background-image: url("./elice_logo.png");
background-repeat: no-repeat;
background-position: center;


<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>CSS 주요 속성 2</title>
  
  <style>
    
    .paragraph {
      width: 500px;
      height: 500px;
      
      font-size; 50px;
      font-weight: bold;
      font-style: italic;
      font-family: Arial, times, sans-serif;
      
      /* 지시사항 1번 내용을 코드로 작성해보세요. */
    border-style: solid;
    border-width: 2px;
    border-color: red;  
      
      /* 지시사항 2번 내용을 코드로 작성해보세요. */
    background-color: yellow;
    background-image: url("./elice_logo.png");
    background-repeat: no-repeat;
    background-position: center;  
      
    }
    
  </style>
  
</head>
<body>
  
  <h1 class="paragraph">Nice to meet you</h1>
  
</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
지시사항
작성되어 있는 index.html에서 아래의 각 지시사항에 제시된 태그의 class를 찾은 후, 조건에 맞도록 index.css 파일을 작성해 주세요.

<h2></h2> 태그의 속성과 속성값이 아래와 같이 되도록 css를 작성합니다.

글씨 크기: 80px
글씨 굵기: bold
글씨 색: white
배경 색: blue
<p></p> 태그의 속성과 속성값이 아래와 같이 되도록 css를 작성합니다.

글씨 크기: 20px
글씨 스타일: italic
글씨 색: green
<li></li> 태그의 속성과 속성값이 아래와 같이 되도록 css를 작성합니다.

글씨 크기: 50px
글씨 폰트: Arial, sans-serif
글씨 색: red


/* 지시사항을 참고하여 코드를 작성하세요 */

/* header class에 총 4개의 속성을 추가해 주세요 */
.header {
font-size: 50px;
font-weight: bold;
color:white;
background-color: blue;
}

/* paragraph class에 총 3개의 속성을 추가해 주세요 */
.paragraph {
font_size: 20px;
font-style: italic;
font-color:green;  
}

/* list class에 총 3개의 속성을 추가해 주세요 */
.list {
font_size: 50px;
font-family: Arial,sans-serif;
color: red;  
}
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
웹사이트의 레이아웃

박스 모델 구조

margin
border
padding
content

-margin과 padding의 차이-

<style>
 div {
      .......
      margin-left: 100px;
      padding-left: 100px;
     }
</style>


margin-left
border 바깥쪽에서 왼쪽에 여백을 만듦

padding-left
border 안쪽에서 왼쪽에 여백을 만듦
공간이 여백을 포함한 크기로 변경되는 점 유의


margin과 padding 작성 방법
<style>
   div { margin: 100px 0 0 100px; }
</style>

top right bottom left 순서로 한 줄에 작성 가능
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
박스모델
박스 모델은 웹사이트 레이아웃을 구성하는 요소들 중 하나입니다.
border를 기준으로, 바깥쪽은 margin,
안쪽은 padding입니다.
박스 가장 안쪽에는 내용을 담는 content가 있습니다.
<div>에 박스모델을 적용해 봅시다.

지시사항
넓이와 높이를 각각 300px로 설정합니다.
width: 300px;
height: 300px;
Copy
배경색을 노란색으로 설정합니다.
background-color: yellow;
Copy
테두리는 빨간색 실선으로, 두께는 10px로 설정합니다.
border: solid 10px red;
Copy
margin-left과 padding-left를 각각 100px로 설정합니다.
margin-left: 100px;
padding-left: 100px;


<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>박스모델</title>

  <style>
    div {
      /* 지시사항 1번 내용을 코드로 작성해보세요. */
width: 300px;
height: 300px;

      /* 지시사항 2번 내용을 코드로 작성해보세요. */
background-color: yellow;

      /* 지시사항 3번 내용을 코드로 작성해보세요. */
border: solid 10px red;

      /* 지시사항 4번 내용을 코드로 작성해보세요. */
margin-left: 100px;
padding-left: 100px;

    }
  </style>

</head>
<body>

  <div>Hello World</div>

</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Block요소와 Inline 요소

<!-- Block 요소 -->
<p>Hello Elice</p>
<p>Hello Elice</p>
<p>Hello Elice</p>

<p>태그 : Block 요소

<!-- Inline 요소 -->
<a>Bye Elice</a>
<a>Bye Elice</a>
<a>Bye Elice</a>

<a>태그 : Inline 요소


Block 요소의 특징
<style>
   p {
      width: 200px;
      height: 200px;
      margin-top: 100px;
     }
</style>

- <p>태그가 대표적
- 줄바꿈 현상이 나타남
- width height 값 사용 가능 -> 공간 만들기 가능
- margin과 padding 값 사용 가능 -> 상하 배치 작업 가능
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Block 요소와 Inline 요소
Block 요소는 줄바꿈 현상이 일어나는 y축 정렬 형태인 반면, Inline 요소는 줄바꿈 현상이 일어나지 않는 x축 정렬 형태입니다.
Block 요소는 Inline 요소와 다르게 width와 height를 지정하여 공간을 만들 수 있습니다. 또한, margin과 padding을 사용하여 상하배치 작업이 가능합니다.
width, height, margin을 사용하여 두 요소의 차이를 확인해 봅시다!


지시사항
<p>와 <a> 두 태그를 구분하기 위해 <p>의 배경색은 노란색(yellow), margin-top은 100px로 설정합니다.
background-color: yellow;
margin-top: 100px;
Copy
<p>와 <a> 두 태그를 구분하기 위해 <a>의 배경색은 분홍색(pink), margin-top은 100px로 설정합니다.
다.
background-color: pink;
margin-top: 100px;
Copy
두 태그들이 어떻게 다르게 출력되는지 확인해보세요!


<!DOCTYPE html>
<html>

<head>

  <meta charset="UTF-8">
  <title>Block 요소와 Inline 요소</title>

  <style>
    p {
      width: 200px;
      height: 200px;
      /* 지시사항 1번을 코드로 작성해보세요. */
background-color: yellow;
margin-top: 100px;
    }

    a {
      width: 200px;
      height: 200px;
      /* 지시사항 2번을 코드로 작성해보세요. */
background-color: pink;
margin-top: 100px;
    }
  </style>

</head>

<body>

  <!-- Block 요소 -->
  <p>Block 요소</p>
  <p>Block 요소</p>
  <p>Block 요소</p>

  <!-- Inline 요소 -->
  <a href="#">Inline 요소</a>
  <a href="#">Inline 요소</a>
  <a href="#">Inline 요소</a>

</body>

</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
마진 병합 현상

형제지간의 마진 병합
<div class="box1">Hello World</div>
<div class="box2">Hello World</div>

/* style.css 문서 */
.box1 { margin-bottom: 150px; }
.box2 { margin-top: 100px; }

marign-bottom과 bottom-top 중 숫자가 큰 값으로 적용

부모 자식간의 마진 병합
<main role="main>                  */style.css 문서
   <article>                              article {
   </article>                             width: 200px;
</main>                                  height: 200px;
                                             margin-top: 100px;
                                             }

자식인 <article> 뿐만 아니라 부모인 <main>에도 영향을 미침
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
레이아웃에 영향을 미치는 속성

-display-

/* style.css 문서 */
p { display: inline; }
a { display: block; }
a { display: inline-block; }

Block과 Inline 요소의 성격을 바꿀 때 사용, inline-block을 사용하면 두 요소의 성격을 모두 가짐


-float-
앨범 사진이 왼쪽에 있느냐 오른쪽에 있느냐
<div class - "left"> Hello World </div>
<div class - "right"> Hello World </div>

*/ style.css 문서 */
.left { float: left; }
.right { float: right; }

선택된 요소를 왼쪽 끝 혹은 오른쪽 끝에 정렬 시키고자 할 때 사용
이름 그대로 선택자를 띄워 새로운 레이어층을 만드는 것

레이어가 겹치지 않는 상태로 왼쪽에서부터 정렬시키고 싶은 경우
folat: left; 을 연속적으로 입력


-clear-
<header></header>
<aside class="left">Hello World</aside>
<main></main>
<aside class="right">Hello World</aside>
<footer></footer>

*/ style.css 문서 */
footer { clear: both; }
---float에 대한 속성을 제어하고자 할 때


브라우저와 공간 사이의 공백 제거하기

<style>                                                     <style>
   html, body {                                               *{
             margin: 0;                                          margin: 0;
             padding: 0'                                        padding: 0;
              }                                                     }
</style>                                                     </style>

<html>과 <body>태그는 margin과                          혹은 *로 모든 html 태그 선택 가능
padding 값을 가지므로 초기화를 해주어야 함
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
레이아웃에 영향을 미치는 속성 - display
display 속성을 사용하면 block 요소와 inline 요소의 성격을 바꿀 수 있습니다.

지시사항
실행버튼을 눌러 결과를 먼저 확인해봅시다.
display를 사용하여 <p>의 요소를 inline으로 바꿉니다.
display: inline;
Copy
display를 사용하여 <a>의 요소를 block으로 바꿉니다.
display: block;
Copy
다시 실행버튼을 눌러 변경된 결과를 확인 해보세요.


<!DOCTYPE html>
<html>
<head>

  <meta charset="UTF-8">
  <title>레이아웃에 영향을 미치는 속성 : display</title>
  
  <style>
    p {
      width: 300px;
      height: 300px;
      background-color: pink;
      /* 지시사항 1번 내용을 코드로 작성해보세요. */
display: inline;
    }
    
    a {
      width: 300px;
      height: 300px;
      background-color: yellow;
      /* 지시사항 2번 내용을 코드로 작성해보세요. */
display: block;
    }
  </style>
  
</head>
<body>

   <p>Block Element</p>
   <p>Block Element</p>
   <p>Block Element</p>
   
   <a href="#">Inline Element</a>
   <a href="#">Inline Element</a>
   <a href="#">Inline Element</a>

</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
레이아웃에 영향을 미치는 속성 - float
float은 선택된 요소를 왼쪽에서부터 또는 오른쪽에서부터 정렬시키고자 할 때 사용되는 CSS 속성입니다. 속성값으로는 보통 left, right이 사용됩니다.
<div>와 <article>의 float 속성값을 입력해보며 float에 대해 알아봅시다!

지시사항
#left를 맨 왼쪽에 정렬하기 위해 float: left;를 입력합니다.
float: left;
Copy
main을 #left 바로 옆에 순차적으로 왼쪽 정렬하기 위해 float: left;를 입력합니다.
float: left;
Copy
#right을 맨 오른쪽에 정렬하기 위해 float: right;를 입력합니다.
float: right;
Copy
실행버튼을 눌러 결과를 확인해봅시다.


<!DOCTYPE html>
<html>
<head>

  <meta charset="UTF-8">
  <title>레이아웃에 영향을 미치는 속성 - float</title>

  <style>
    header {
      width: 100%;
      height: 100px;
      background-color: yellow;
    }

    #left {
      width: 200px;
      height: 200px;
      background-color: red;
      /* 지시사항 1번 내용을 코드로 작성해보세요. */
float: left;
    }

    main {
      width: 300px;
      height: 200px;
      background-color: green;
      /* 지시사항 2번 내용을 코드로 작성해보세요. */
float: left;
    }

    #right {
      width: 200px;
      height: 200px;
      background-color: pink;
      /* 지시사항 3번 내용을 코드로 작성해보세요. */
float: right;
    }

    footer {
      width: 100%;
      height: 100px;
      background-color: black;
    }
  </style>

</head>

<body>

  <header></header>

  <article id="left"></article>

  <main></main>

  <article id="right"></article>

  <footer></footer>

</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
레이아웃에 영향을 미치는 속성 - clear
clear 속성을 이용하면 float 속성을 제어할 수 있습니다.
앞선 실습의 검은색 <footer>영역이 페이지 하단에 배치될 수 있도록, clear 속성을 입력해 봅시다!
또한 margin과 padding을 사용하여 브라우저와 공간 사이의 여백을 제거해 봅시다!

지시사항
<style> 태그 안에서 <footer>의 clear 속성값으로 both를 넣어주어, float 속성을 제어합니다.
clear: both;
Copy
<style> 태그 안에서 <html>과 <body>의 margin과 padding 값으로 각각 0을 입력하여, 브라우저 상의 여백을 제거합니다.
html, 
body {
    margin:0; 
    padding:0;
}



<!DOCTYPE html>
<html>
<head>

  <meta charset="UTF-8">
  <title>레이아웃에 영향을 미치는 속성 - clear</title>
  
  <style>
    
    header {
      width: 100%;
      height: 100px;
      background-color: yellow;
    }
    
    #left {
      float: left;
      
      width: 200px;
      height: 200px;
      background-color: red;
    }
    
    main {
      float: left;
      
      width: 300px;
      height: 200px;
      background-color: green;
    }
    
    #right {
      float: right;
      
      width: 200px;
      height: 200px;
      background-color: pink;
    }
    
    footer {
      width: 100%;
      height: 100px;
      background-color: black;
      
      /* 지시사항 1번 내용을 코드로 작성해보세요. */
 clear: both;     
    }

    /* 지시사항 2번 내용을 코드로 작성해보세요. */
html, 
body {
    margin:0; 
    padding:0;
}    
    
  </style>
  
</head>
<body>

  <header></header>
  
  <article id="left"></article>
  <main role="main"></main>
  <article id="right"></article>
  
  <footer></footer>

</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
마진 병합 현상
#box1과 #box2의 css속성을 바꿔보며 형제 지간의 마진 병합 현상에 대해 알아봅시다.
또한 <main>과 <article>의 css속성을 바꿔보며 부모 자식 지간의 마진 병합 현상에 대해 알아봅시다.


지시사항
형제지간의 마진병합
box1의 margin-bottom을 150px으로 설정합니다.
margin-bottom: 150px;
Copy
box2의 margin-top을 100px으로 설정합니다.
margin-top: 100px;
Copy
실행 버튼을 눌러 화면에 어떻게 표시되는지 확인합니다.


<!DOCTYPE html>
<html>
<head>

  <meta charset="UTF-8">
  <title>마진병합현상</title>
  
  <style>
    #box1 {
      width: 100%;
      height: 200px;
      background-color: yellow;
      /* 지시사항 1번 내용을 코드로 작성해보세요. */
 margin-bottom: 150px;     
    }  
    
    #box2 {
      width: 100%;
      height: 200px;
      background-color: pink;
      /* 지시사항 2번 내용을 코드로 작성해보세요. */
 margin-top: 100px;     
    }
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
부모자식간의 마진병합

main 태그의 width를 100%, height를 400px, 배경색을 노란색, margin-top을 100px로 설정합니다.

main {
    width: 100%;
    height: 400px;
    background-color: yellow;
    margin-top: 100px;
}
Copy
article 태그의 width를 100%, height를 100px, 배경색을 빨간색, margin-top을 100px로 설정하고 실행해봅시다.

article {
  width: 100px;
  height: 100px;
  background-color: red;
  margin-top: 100px;
}



   /* 지시사항 4번 내용을 코드로 작성해보세요. */
main {
    width: 100%;
    height: 400px;
    background-color: yellow;
    margin-top: 100px;
}    
    
    /* 지시사항 5번 내용을 코드로 작성해보세요. */
article {
  width: 100px;
  height: 100px;
  background-color: red;
  margin-top: 100px;
}    
    
  </style>
  
</head>
<body>
  
  
  <!-- 형제 지간에 발생하는 마진 병합 현상 -->
  <div id="box1"></div>
  <div id="box2"></div>
  
  
  <!-- 부모 자식 지간에 발생하는 마진 병합 현상 -->
  <main role="main">  
    <article></article>
  </main>
  

</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
자바스크립트

자바스크립트란:
이미지 슬라이드 효과, 팝업 효과 등의 기능을 포함한
동적인 웹사이트 제작 시 사용되는 프로그래밍 언어.
HTML 내용
CSS 디자인
JS 동작

자바스크립트 활용 범위
IOT / 하이브리드 앱 / 서버 개발
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
자바스크립트의 변수

변수란? 데이터를 담는 공간
데이터        ->        변수


변수 선언 및 데이터 저장
var fruit;      //변수 선언
fruit    =     "apple"   //변수 초기화
변수명         데이터

var fruit = "apple";   //변수 선언 및 초기화

변수선언
데이터를 담을 공간을 생성하는 것

변수 초기화
생성된 변수에 데이터를 전달하는 것


var fruit = "apple";

fruit = "banana"

변수 fruit의 데이터를 apple 에서 banana로 변경
변수는 이미 선언되었으므로 var 다시 작성할 필요가 없다.


var fruit = "apple";

console.log(fruit);   //apple출력

console.log(); 는 변수 안에 데이터를 확인할 때 사용하는 명령어


-변수 생성 시 주의 사항-
//변수명은 숫자로 시작할 수 없음
var 1str;   X
//변수명은 최대한 자세하게 작성
var randomNumber;
//의미가 불명확한 단어들의 조합은 피해야 함
var tmax;

-자바스크립트 사용 방법-
<body>
   <script src="index.js"></script>
</body>

<script> 태그 안에 src의 속성값으로 js 파일을 입력 후 html 파일과 연동


-변수 데이터 확인 방법-
우 클릭 후 크롬 개발자 검사 or F12
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
변수 생성
변수는 데이터를 담는 공간을 의미합니다.

자바스크립트에서 변수를 생성하려면 var 변수명;을, 변수의 데이터를 콘솔에서 확인하려면 console.log(변수명);을 작성해야 합니다.
그리고 변수의 데이터를 웹 화면에 출력하기 위해서는 document.write(변수명)을 사용하실 수 있습니다.

var num
num = 1;

var str = "Hello World"
str = "Nice to meet you";

console.log(num);
console.log(str);

document.write(num);
document.write(str);


지시사항
var를 사용하여 변수 fruit을 선언하고, 데이터 apple을 삽입합니다.
var fruit;
fruit = "apple";
Copy
var를 사용하여 변수 box를 선언하고, 데이터 banana를 삽입합니다.
var box = "banana";
Copy
document.write();을 사용하여 변수 fruit과 box의 데이터를 확인합니다.
document.write(fruit);
document.write(box);
Copy
변수 box의 데이터를 tomato로 변경합니다.
box = "tomato";
Copy
document.write();을 사용하여 변수 box의 변경된 데이터를 확인합니다.
document.write(box);
Copy
출력 결과
applebananatomato


/* 지시사항 1번 내용을 코드로 작성해보세요. */
var fruit;
fruit = "apple";

/* 지시사항 2번 내용을 코드로 작성해보세요. */
var box = "banana";

/* 지시사항 3번 내용을 코드로 작성해보세요. */
document.write(fruit);
document.write(box);

/* 지시사항 4번 내용을 코드로 작성해보세요. */
box = "tomato";

/* 지시사항 5번 내용을 코드로 작성해보세요. */
document.write(box);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
자바스크립트 데이터 타입

데이터 타입이란?
초콜릿도 다양한 종류가 존재하듯 변수에 전달되는 데이터 타입에도 여러 종류가 존재한다.

-8가지 데이터 타입-
string 문자열
Number 숫자
Function 함수
Array 배열
Object 객체
Boolean 불린
undefined 정의되지 않음
null 널


-문자열-
var str1 = "Hello World";
var str2 = 'Nice to meet you';
var str3 = "20";   //숫자가 아닌 문자열
큰 따옴표 또는 작은 따옴표 안에 작성된 데이터

문자열 주의 사항 - 큰 따옴표 또는 작은 따옴표 혼용 불가


-숫자-
var num1 = 10;   정수
var num2 = -10;   음수
var num3 = 3.14;   실수

-함수-
var func1 = function() {
       console.log("Func1");
} // 함수 생성

func1(); // 함수 호출


function func1() {
       console.log("Func1");
} // 함수 생성

func1(); // 함수 호출


함수 생성 - function 키워드를 사용하여 생성
함수 호출 - 함수 안에 있는 코드를 실행시키겠다는 의미


-함수-
var area = function(width, height) {
       return width * height;
}
area(10, 20);

매개변수: 인자로부터 전달받은 값이 들어가는 통로, 상황에 따라 생략 가능
인자: 함수에게 전달하는 데이터
return: 함수 안에 데이터를 저장할 때 사용

-함수-
하나의 커피머신(함수)
투입구(매개변수)
원두(인자)
커피(return)

-함수 데이터 호출 방법-
var area = function(width, height) {
       return width * height;
}

//새 변수를 생성한 후, 그 변수를 console.log()로 감싸기
var result = area(10, 20);
console.log(result);

//함수 자체를 console.log()로 감싸기
console.log(area(10, 20));


-배열-     비슷한 성격을 갖고 있는 데이터를 하나의 변수 안에서 관리
var fruit = ["사과", "배", "수박"];

console.log(fruit); //데이터 확인



-배열-     데이터의 좌표값(index)작성, 첫 번째 좌표값은 0
var fruit = ["사과", "배", "수박"];
                  0       1       2
console.log(fruit[0]); // 0번째 인덱스의 데이터 추출



-배열 데이터 변경하기-     인덱스를 사용하여 접근 후 새로운 데이터 대입
var fruit = ["사과", "배", "수박"];
fruit[0] = "포도"

console.log(fruit);



-객체-     프로퍼티, 메서드, 데이터로 구성 / 여러 종류의 데이터 타입 삽입 가능
var student = {
프로퍼티 name : "inkwon", 데이터
             age : 20,
             skills : ["자바스크립트", "HTML", "CSS],
메서드 sum : function (num1, num2) { return num1 + num2; }
        }



-객체 데이터 출력하기-
var student = {
             name : "inkwon", 데이터
             age : 20,
             skills : ["자바스크립트", "HTML", "CSS],
             sum : function (num1, num2) { 
                  return num1 + num2; 
        }
}

console.log(student.name);  //객체명.프로퍼티명
console.log(student['name']);  //객체명["프로퍼티명"]



-객체 데이터 변경하기-
var student = {
             name : "inkwon", 데이터
             age : 20,
             skills : ["자바스크립트", "HTML", "CSS],
             sum : function (num1, num2) { 
                  return num1 + num2; 
        }
}

student.name = "Park";  //name 프로퍼티의 데이터 변경
console.log(student.name);  //Park 출력


-undefined, null-

var unde;

var empty = null;

undefined: 변수 안에 데이터를 입력하지 않은 상태(데이터가 없는 것)
null: 개발자가 임의로 변수 안에 빈 데이터를 삽입한 상태(빈 데이터를 지정한 것)


-Boolean-   참 또는 거짓 데이터가 들어가 있는 상태

var t = true;
var f = false;
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
데이터 타입 - 문자열
문자열 데이터 타입은, 큰따옴표 또는 작은 따옴표로 작성된 데이터를 의미합니다.

var str1 = "Hello";
var str2 = "Bye";
var str3 = "100";
Copy
실습을 통해 문자열 데이터 타입을 갖는 변수를 생성해 봅시다!



지시사항
var를 사용하여 문자열 변수 str1을 선언하고, 데이터 “Hello World” 을 삽입합니다.
var str1 = "Hello World";
Copy
var를 사용하여 문자열 변수 str2을 선언하고, 데이터 ‘Nice to meet you’ 을 삽입합니다.
var str2 = "Nice to meet you";
Copy
var를 사용하여 문자열 변수 str3을 선언하고, 데이터 “She’s a girl” 을 삽입합니다.
var str3 = "She's a girl";
Copy
document.write(); 또는 document.writeln();를 사용하여 세 변수들을 출력합니다.
document.write(str1);
document.write(str2);
document.write(str3);



/* 지시사항 1번 내용을 코드로 작성해보세요. */
var str1 = "Hello World";

/* 지시사항 2번 내용을 코드로 작성해보세요. */
var str2 = "Nice to meet you";

/* 지시사항 3번 내용을 코드로 작성해보세요. */
var str3 = "She's a girl";

/* 지시사항 4번 내용을 코드로 작성해보세요. */
document.write(str1);
document.write(str2);
document.write(str3);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
데이터 타입 - 숫자
숫자 데이터 타입은 별도의 기호없이 숫자를 입력한 상태를 의미합니다.
var num1 = 30;
var num2 = 10.5;
Copy
실습을 통해 숫자 데이터 타입을 갖는 변수를 생성해 봅시다!



지시사항
var를 사용하여 숫자 변수 num1을 생성하고, 데이터 10을 삽입합니다.
var num1 = 10;
Copy
var를 사용하여 숫자 변수 num2를 생성하고, 데이터 3.14을 삽입합니다.
var num2 = 3.14;
Copy
document.write(num1 + num2) 를 입력해 num1과 num2를 더한 값을 알아봅니다.
document.write(num1+num2);


/* 지시사항 1번 내용을 코드로 작성해보세요. */
var num1 = 10;

/* 지시사항 2번 내용을 코드로 작성해보세요. */
var num2 = 3.14;

/* 지시사항 3번 내용을 코드로 작성해보세요. */
document.write(num1+num2);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
데이터 타입- 함수
함수는 function 키워드를 사용하여, 어떤 기능을 만들 때 사용되는 데이터 타입을 의미합니다.
함수는 매개변수, 인자, return으로 구성되어 있습니다.
함수를 생성하는 방법은 다음 두 가지입니다.

var subtract = function(num1, num2) {
    return num1-num2;
}
Copy
function subtract(num1, num2) {
    return num1-num2;
}

console.log(subtract(20,10));
Copy
실습을 통해 덧셈 함수와 곱셈 함수를 생성해 봅시다!




지시사항
var를 사용하여 함수를 선언합니다. 함수명은 sum, 매개변수는 num1, num2, return값은 num1+num2로 설정합니다.
var sum = function(num1, num2) {
    return num1 + num2;
}
Copy
함수 sum의 인자로 10, 20을 넣고, document.write();를 사용하여 값을 확인합니다.
document.write(sum(10, 20));
Copy
function만을 사용하여 함수를 선언합니다. 함수명은 mul, 매개변수는 num3, num4, return값은 num3 * num4로 설정합니다.
function mul(num3, num4) {
    return num3 * num4;
}
Copy
함수 mul의 인자로 3, 4를 넣고, document.write();를 사용하여 값을 확인합니다.
document.write(mul(3,4));



/* 지시사항 1번 내용을 코드로 작성해보세요. */
var sum = function(num1, num2) {
    return num1 + num2;
}

/* 지시사항 2번 내용을 코드로 작성해보세요. */
document.write(sum(10, 20));

/* 지시사항 3번 내용을 코드로 작성해보세요. */
function mul(num3, num4) {
    return num3 * num4;
}

/* 지시사항 4번 내용을 코드로 작성해보세요. */
document.write(mul(3,4));
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
데이터 타입 - 배열
배열은 비슷한 성격을 갖고 있는 복수의 데이터를, 하나의 변수 안에 관리하기 위해 사용됩니다.
배열은 index와 값으로 구성되어 있습니다.

var vegetables = ["carrot", "cucmber", "onion"];
Copy
실습을 통해, 여러 과일들을 담고 있는 배열 fruit을 만들어 봅시다!



지시사항
var를 사용하여 변수 fruit을 선언하고, 배열 데이터 타입인 [“Apple”, “Banana”] 데이터를 삽입합니다.
var fruit = ["Apple", "Banana"];
Copy
document.write();를 사용하여 fruit의 데이터를 확인합니다.
document.write(fruit);
Copy
document.write(fruit[0]);를 입력하여, fruit의 배열에서 첫 번째 데이터가 무엇인지 확인합니다.
document.write(fruit[0]);
Copy
fruit 배열의 첫 번째 데이터를 “Tomato” 로 변경합니다.
fruit[0] = "Tomato";
Copy
document.write();를 사용하여 데이터가 올바르게 변경됐는지 확인합니다.
document.write(fruit);


/* 지시사항 1번 내용을 코드로 작성해보세요. */
var fruit = ["Apple", "Banana"];

/* 지시사항 2번 내용을 코드로 작성해보세요. */
document.write(fruit);

/* 지시사항 3번 내용을 코드로 작성해보세요. */
document.write(fruit[0]);

/* 지시사항 4번 내용을 코드로 작성해보세요. */
fruit[0] = "Tomato";

/* 지시사항 5번 내용을 코드로 작성해보세요. */
document.write(fruit);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
데이터 타입 - 객체
자신의 프로필 정보를 담고 있는 객체를 생성해 객체는 배열과 마찬가지로, 여러 개의 데이터를 담을 때 사용되는 데이터 타입입니다.
객체는 프로퍼티, 메서드, 값으로 구성되어 있습니다.
var student= {
  name : "Gildong",
  age : 19,
  skills : ["studying", "eating", "sleeping"],
  sum : function (num1, num2) {
      return num1 + num2;
  }
}
Copy
실습을 통해 Elice 학생의 정보를 담은 객체를 생성해 봅시다!



지시사항
var를 사용하여 변수 student를 선언하고, 객체 데이터 타입을 넣기 위해 중괄호{}를 입력합니다.
객체에 프로퍼티 name: "Elice", age:20, skills: ["Java", "HTML", "CSS", "JavaScript"]를 추가합니다.
객체에 메서드 sum: function(num1,num2) { return num1 + num2; }를 추가합니다.
var student = {
    name: "Elice",
    age: 20,
    skills: ["Java", "HTML", "CSS", "JavaScript"],
    sum: function(num1,num2) {
     return num1 + num2;
    }
}
Copy
name의 데이터를 park으로 변경하고, document.write();를 사용하여 올바르게 변경됐는지 확인합니다.
student.name = "park";

document.write(student.name);
Copy
sum 메서드에 인자 10, 20을 넣고, document.write();를 사용하여 올바르게 출력되는지 확인합니다.
document.write(student.sum(10, 20));



/* 지시사항 1번 내용을 코드로 작성해보세요. */
var student = {
    name: "Elice",
    age: 20,
    skills: ["Java", "HTML", "CSS", "JavaScript"],
    sum: function(num1,num2) {
     return num1 + num2;
    }
}

/* 지시사항 2번 내용을 코드로 작성해보세요. */
student.name = "park";

document.write(student.name);

/* 지시사항 3번 내용을 코드로 작성해보세요. */
document.write(student.sum(10, 20));
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
데이터 타입 - undefined, null
undefined는 변수 안에 데이터를 입력하지 않은 상태를 의미합니다.
null은 개발자가 임의로 변수 안에 빈 데이터를 삽입한 상태를 의미합니다.
var unde;  //undefined
var empty = null;  //null
Copy
실습을 통해 undefined, null 데이터 타입을 갖는 변수를 생성해 봅시다!



지시사항
아무 데이터도 넣지 않은 변수 str1을 생성하고, document.write()로 어떻게 출력되는지 확인합니다.
데이터 null값을 넣은 변수 empty를 생성하고, document.write()로 어떻게 출력되는지 확인합니다.


var unde;  //undefined
var empty = null;  //null

document.write(unde);
document.write(empty);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
데이터 타입 - Boolean
Boolean은 참 또는 거짓인 상태를 의미합니다.
var t = true;
var f = false;
Copy
실습을 통해 참과 거짓 정보를 담고 있는 변수를 생성해 봅시다!


지시사항
true 값을 갖는 변수 t를 선언합니다.
false 값을 갖는 변수 f를 선언합니다.
두 변수를 document.write()로 출력하여 데이터를 확인합니다.


var t = true;
var f = false;

document.write(t)
document.write(f)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
배열 안의 배열 데이터에 접근하기
배열 안의 데이터에 접근할 때는 대괄호[ ]를 써서 인덱싱을 하였습니다.
이번 미션에서는 배열 안의 배열에 접근해 봅시다.


지시사항
arrTest배열에서 3000이란 값을 찾아 document.write()로 출력해보세요.

var arrTest = [
    [100, 200, 300],
    [1000, 2000, 3000],
    [1111, 2222, 3333]
];


// 배열 안의 데이터에 접근하는 방법을 응응하여,
// 다음 배열에서 숫자 3000에 접근해 보세요.
var arrTest = [
    [100, 200, 300],
    [1000, 2000, 3000],
    [1111, 2222, 3333]
];

document.write(arrTest[1][2]);  // 3000 출력
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
자바스크립트 객체와 연산

-자바스크립트의 프로퍼티와 메서드-

데이터 타입의 프로퍼티와 메서드:
초콜릿의 종류별 갖고 있는 고유한 성질, 자바스크립트에서 사용자를 위해 사전에 작성된 편의 기능

-문자열 프로퍼티와 메서드-
var stl1 = "Hello World";
str1.length;     문자열 길이
str1.charAt(0);   문자열 H 추출
str1.split(" ");   공백 기준으로 문자 나눈 후 배열 [Hello, World]로 출력

-배열 프로퍼티와 메서드-
var fruit = ["사과", "배", "포도"];

fruit.length;      데이터 개수

fruit.push("딸기");   배열 뒤에 데이터 삽입
fruit.unshift("레몬")   배열 앞에 데이터 삽입

fruit.pop();   배열 뒤의 데이터 제거
fruit.shift();   배열 앞의 데이터 제거


-math의 수학 연산 메서드-
Math.abs(-3)   절대값
Math.ceil(0.3);   올림
Math.floor(10.9);   내림
Math.random();   임의의 숫자 출력


-문자를 숫자로 변환하는 메서드
parseInt("20.6")   정수 형태의 20 변환
parseFloat("20.6")   실수 형태의 20.6 변환
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
프로퍼티와 메서드 - 문자열
문자열 메서드로는 length, charAt, split 등이 있습니다.

var str1 = "Hi!Elice";

str1.length;  // 8
str1.charAt(1);  // i
str1.split("!");  // [Hi, Elice]
Copy
실습을 통해 문자열 “Hello World” 에 세 가지 메서드를 적용해 봅시다!


지시사항
문자열 “Hello World” 를 데이터로 갖는 변수 str1을 선언합니다.
var str1 = "Hello World";
Copy
.length를 사용하여 변수의 길이를 확인합니다.
document.write(str1.length);
Copy
.charAt을 사용하여 0번째 데이터를 확인합니다.
document.write(str1.charAt(0));
Copy
.split을 사용하여 공백" "을 기준으로 문자열을 나눕니다.
document.write(str1.split(" "));
Copy
위 변수들을 document.write()로 출력하여 데이터를 확인합니다.


/* 지시사항 1번 내용을 코드로 작성해보세요. */
var str1 = "Hello World";

/* 지시사항 2번 내용을 코드로 작성해보세요. */
document.write(str1.length);

/* 지시사항 3번 내용을 코드로 작성해보세요. */
document.write(str1.charAt(0));

/* 지시사항 4번 내용을 코드로 작성해보세요. */
document.write(str1.split(" "));
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
프로퍼티와 메서드 - 배열
배열 메서드로는 length, push, unshift, pop, shift 등이 있습니다.

var fruit = ["사과", "배", "포도"];

fruit.length;  //3
fruit.push("딸기");  // ["사과", "배", "포도", "딸기"]
fruit.unshift("레몬");  // ["레몬", "사과", "배", "포도", "딸기"]
fruit.pop();  // ["레몬", "사과", "배", "포도"]
fruit.shift();  // ["사과", "배", "포도"]
Copy
실습을 통해 배열 fruit에 다섯 가지 메서드를 적용해 봅시다!



지시사항
배열 [“Apple”, “Banana”, “Tomato”] 를 데이터로 갖는 변수 fruit을 선언합니다.
var fruit = ["Apple", "Banana", "Tomato"];
Copy
.length를 사용하여 변수의 길이를 확인합니다.
document.write(fruit.length);
Copy
push를 사용하여 배열 맨 끝에 데이터 “A” 를 추가합니다.
fruit.push("A");
Copy
unshift를 사용하여 배열 맨 앞에 데이터 “B” 를 추가합니다.
fruit.unshift("B");
Copy
document.write();를 사용하여 데이터가 올바르게 추가됐는지 확인합니다.
document.write(fruit);
Copy
pop을 사용하여 배열 맨 끝 데이터를 제거합니다.
fruit.pop();
Copy
shift를 사용하여 배열 맨 앞 데이터를 제거합니다.
fruit.shift();
Copy
document.write();를 사용하여 데이터가 올바르게 제거됐는지 확인합니다.
document.write(fruit);


/* 지시사항 1번 내용을 코드로 작성해보세요. */
var fruit = ["Apple", "Banana", "Tomato"];

/* 지시사항 2번 내용을 코드로 작성해보세요. */
document.write(fruit.length);

/* 지시사항 3번 내용을 코드로 작성해보세요. */
fruit.push("A");

/* 지시사항 4번 내용을 코드로 작성해보세요. */
fruit.unshift("B");

/* 지시사항 5번 내용을 코드로 작성해보세요. */
document.write(fruit);

/* 지시사항 6번 내용을 코드로 작성해보세요. */
fruit.pop();

/* 지시사항 7번 내용을 코드로 작성해보세요. */
fruit.shift();

/* 지시사항 8번 내용을 코드로 작성해보세요. */
document.write(fruit);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
프로퍼티와 메서드 - 문자를 숫자로 변환하는 메서드
문자열 데이터 타입을 숫자열 데이터 타입으로 변환시키고자 할 때는 parseInt(), parseFloat() 메서드를 사용하면 됩니다.

parseInt("20.6");  // 20
parseFloat("20.6");  // 20.6
Copy
실습을 통해 문자열 데이터 타입 “20.14” 를 숫자 데이터 타입으로 바꿔 봅시다!



지시사항
변수 str1에 문자열 데이터 “20.14” 를 입력합니다.
var str1 = "20.14";
Copy
parseInt()를 사용하여 str1을 정수형 데이터 타입으로 변환시켜 document.write로 출력하여 확인해봅시다.
document.write(parseInt(str1));
Copy
parseFloat()를 사용하여 str1을 실수형 데이터 타입으로 변환시켜 document.write로 출력하여 확인해봅시다.
document.write(parseFloat(str1));


/* 지시사항 1번 내용을 코드로 작성해보세요. */
var str1 = "20.14";

/* 지시사항 2번 내용을 코드로 작성해보세요. */
document.write(parseInt(str1));

/* 지시사항 3번 내용을 코드로 작성해보세요. */
document.write(parseFloat(str1));
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
연산자

-산술 연산자-   숫자 뿐 아니라 문자열도 산술 연산자 사용 가능
console.log(20 + 10);  //30
console.log(20 - 10);  //10
console.log(20 * 10);  //200
console.log(20 / 10);  //2
console.log(20 % 10);  //0

console.log("20" + 10);  //2010
console.log("20" - 10);  //10
console.log("20" * 10);  //200
console.log("20" / 10);  //2
console.log("20" % 10);  //0


-증감 연산자-     ++ 1씩 증가 / -- 1씩 감소
var num = 10;

console.log(++num);  // num+1 후 num출력
console.log(--num);  // num-1 후 num출력

console.log(num++);  // num출력 후 num+1
console.log(num--);  // num출력 후 num-1


-비교 연산자 - 
console.log(10 == 20);  // 값이 같다
console.log(10 === 20);  // 데이터 타입과 값이 같다
console.log(10 !== 20);  // 값이 같지 않다

console.log(10 > 20);
console.log(10 >= 20);
console.log(10 < 20);
console.log(10 <= 20); 


==와 ===의 차이     - Boolean 데이터 타입인 true 혹은 false 반환
console.log(10 == "10");  // true
console.log(10 === "10");  // false


- 논리 연산자-
//앞 뒤 조건 모두 참인 경우에만 true 반환하는 AND 연산자
console.log(10 === 10 && 20 === 30);

//둘 중 하나만 침이여도 true 반환하는 OR 연산자
console.log(10 === 10 | | 20 === 30);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
산술 연산자
산술 연산자는 + - * / %를 의미합니다.
숫자뿐 아니라 문자열 데이터 타입도 산술 연산자를 사용할 수 있습니다.

document.write(10 + 5);  // 15
document.write(10 - 5);  // 5
document.write(10 * 5);  // 50
document.write(10 / 5);  // 2
document.write(10 % 5);  // 0
document.write("10" + "5");  // 105
Copy
실습을 통해 산술 연산자를 사용해 봅시다!



지시사항
숫자 데이터 타입인 20과 10에 산술 연산자 + - * / %를 적용합니다.
document.write(20 + 10);
document.write(20 - 10);
document.write(20 * 10);
document.write(20 / 10);
document.write(20 % 10);
Copy
문자열 데이터 타입인 “20” 과 “10” 에 산술 연산자 + - * / %를 적용합니다.
document.write("20" + "10");
document.write("20" - "10");
document.write("20" * "10");
document.write("20" / "10");
document.write("20" % "10");
Copy
문자열 데이터 타입인 “Elice(공백)” 과 “Lee” 에 산술 연산자 +를 사용합니다.
document.write("Elice " + "Lee");



/* 지시사항 1번 내용을 코드로 작성해보세요. */
document.write(20 + 10);
document.write(20 - 10);
document.write(20 * 10);
document.write(20 / 10);
document.write(20 % 10);

/* 지시사항 2번 내용을 코드로 작성해보세요. */
document.write("20" + "10");
document.write("20" - "10");
document.write("20" * "10");
document.write("20" / "10");
document.write("20" % "10");

/* 지시사항 3번 내용을 코드로 작성해보세요. */
document.write("Elice " + "Lee");
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
증감 연산자
증감 연산자는 ++, --로 작성됩니다. ++는 1씩 증가, --는 1씩 감소를 의미합니다.

var num = 10;
document.write(++num);
document.write(--num);
document.write(num++);
document.write(num--);
Copy
실습을 통해 ++, --를 변수 앞 또는 뒤에 작성했을 때 어떤 차이점이 있는지 확인해 봅시다!



지시사항
숫자 20을 데이터로 갖는 변수 num을 선언합니다.
var num = 20;
Copy
++num 값을 출력해 봅니다.
document.write(++num);
Copy
--num 값을 출력해 봅니다.
document.write(--num);
Copy
num++과 num값을 출력해 봅니다.
document.write(num++);
document.write(num);
Copy
num--과 num값을 출력해 봅니다.
document.write(num--);
document.write(num);



/* 지시사항 1번 내용을 코드로 작성해보세요. */
var num = 20;

/* 지시사항 2번 내용을 코드로 작성해보세요. */
document.write(++num);

/* 지시사항 3번 내용을 코드로 작성해보세요. */
document.write(--num);

/* 지시사항 4번 내용을 코드로 작성해보세요. */
document.write(num++);
document.write(num);

/* 지시사항 5번 내용을 코드로 작성해보세요. */
document.write(num--);
document.write(num);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
비교 연산자
비교 연산자는 변수 안에 담겨 있는 데이터의 상태를 비교할 때 사용됩니다. 비교 연산자로는 == > < 등이 있습니다.
비교 연산자는 값으로 Boolean 데이터 타입인 true 혹은 false를 반환합니다.

document.write(10 == 20);
document.write(10 === 20);
document.write(10 !== 20);

document.write(10 > 20);
document.write(10 >= 20);

document.write(10 < 20);
document.write(10 <= 20);
Copy
실습을 통해 여러 비교 연산자를 직접 적용해 봅시다!



지시사항
10과 10을 ==과 ===을 사용해 비교해 document.writeln()로 출력해보세요.
document.writeln(10 == 10);
document.writeln(10 === 10);
Copy
10과 “10” 을 ==과 ===을 사용해 비교해 document.writeln()로 출력해보세요.
document.writeln(10 == "10");
document.writeln(10 === "10");
Copy
10과 20을 !==을 사용해 비교해 document.writeln()로 출력해보세요.
document.writeln(10 !== 20);
Copy
10과 20을 네 가지 부등호(>, >=, <, <=)를 사용해 비교해 document.writeln()로 출력해보세요.
document.writeln(10 > 20);
document.writeln(10 >= 20);
document.writeln(10 < 20);
document.writeln(10 <= 20);




/* 지시사항 1번 내용을 코드로 작성해보세요. */
document.writeln(10 == 10);
document.writeln(10 === 10);

/* 지시사항 2번 내용을 코드로 작성해보세요. */
document.writeln(10 == "10");
document.writeln(10 === "10");

/* 지시사항 3번 내용을 코드로 작성해보세요. */
document.writeln(10 !== 20);

/* 지시사항 4번 내용을 코드로 작성해보세요. */
document.writeln(10 > 20);
document.writeln(10 >= 20);
document.writeln(10 < 20);
document.writeln(10 <= 20);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
논리 연산자
논리 연산자는 앞뒤 두 조건을 비교할 때 사용되는 연산자입니다.
AND 연산자 &&은 두 조건 모두 참인 경우에만 true를 반환합니다.
OR 연산자 ||는 두 조건 중 하나만 참이어도 true를 반환합니다.

document.write(1 === 1 && 2 === 3);
document.write(1 === 1 || 2 === 3);
Copy
실습을 통해 논리 연산자를 직접 적용해 봅시다!



지시사항
10 === 10 && 20 === 30이 true를 반환하는지 확인합니다.
document.write(10 === 10 && 20 === 30);
Copy
10 === 10 || 20 === 30이 true를 반환하는지 확인합니다.
document.write(10 === 10 || 20 === 30);



/* 지시사항 1번 내용을 코드로 작성해보세요. */
document.write(10 === 10 && 20 === 30);

/* 지시사항 2번 내용을 코드로 작성해보세요. */
document.write(10 === 10 || 20 === 30);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
삼각형의 넓이를 구하는 함수 생성하기
삼각형의 넓이를 구하는 함수 triangle을 만들어 봅시다!
삼각형의 밑변을 나타내는 변수는 width, 높이를 나타내는 변수는 height로 선언합니다.


지시사항
삼각형의 밑변과 높이가 주어졌을 때 삼각형의 넓이를 구하는 함수를 만들고, 밑변이 5, 
높이가 7인 삼각형의 넓이를 document.write()로 확인해보세요.


// 삼각형의 넓이를 구하는 함수를 완성시켜 보세요.
function triangle(width, height) {
    return width * height/2;
    
}

document.write(triangle(5, 7));
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
자바 스크립트 제어문

조건문 - 주어진 조건에 따라 결과값을 출력하는 구문, 조건으로는 비교 연산자 또는 논리 연산자 사용

내일 비가 온다면
참 - 야구 경기는 취소됩니다.
거짓 - 야구 경기는 진행됩니다.


-if 문-  if ( 조건 ) { 수행할 명령 } / 만약 a<b가 참이라면 중괄호 안의 코드를 실행
var a = 20;
var b = 40;

if ( a < b ) {
   console.log("a는 b보다 작다.")
}



-if ~ else 문 - 조건이 true이면 if문 false면 else문 실행
var a = 20;
var b = 40;

if ( a > b ) {
   console.log("a는 b보다 크다.")
} else {
   console.log("a는 b보다 작거나 같다.");
}



-else if 문 - 여러 개의 조건문을 생성할 때 사용
var a = 20;
var b = 40;
var c = 60;

if ( a > b ) {console.log("a는 b보다 크다.")
} else if ( b>c ) {console.log("b는 c보다 크다.");
} else if ( a<c) {console.log("a는 c보다 작다.");
} else if ( b<c ) {console.log("b는 c보다 작다.");
} else {console.log("모든 조건을 만족하지 않는다.");
}



-중첩 if문 - if문 안에 또 다른 if문을 삽입할 때 사용
var a = 20;
var b = 40;

if ( a !== b ) {
    if ( a > b) { console.log("a는 b보다 크다");}
    else { console.log("a는 b보다 작다");}
} else { console.log("a와 b는 같다");}
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
조건문 - else if 문
else if문은 여러 개의 조건문을 생성할 때 사용되는 조건문입니다.

var a = 3;
var b = 6;
var c = 9;

if ( a > b ) { 
 document.write("a는 b보다 크다.");
} else if ( b > c ) { 
 document.write("b는 c보다 크다.");
} else if ( a < c ) { 
 document.write("a는 c보다 작다.");
} else if ( b < c ) { 
 document.write("b는 c보다 작다.");
} else { 
 document.write("모든 조건을 만족하지 않는다.");
}
Copy
실습을 통해 else if 조건문을 직접 만들어 봅시다!



지시사항
var a = 20; var b = 40; var c = 60;을 입력하여 세 변수를 생성합니다.
var a = 20;
var b = 40;
var c = 60;
Copy
조건문을 활용하여 만약 a가 b보다 크면, "a > b" 출력합니다.
if ( a > b ) {
    document.writeln("a > b");
} 
Copy
그렇지 않고, 만약 b가 c보다 크면, "b > c" 출력합니다.
else if ( b > c ) {
    document.writeln("b > c");
} 
Copy
그렇지 않고, 만약 a가 c보다 작으면, "a < c" 출력합니다.
else if ( a < c ) {
    document.writeln("a < c");
} 
Copy
그렇지 않고, 만약 b가 c보다 작으면, "b < c" 출력합니다.
else if ( b < c ) { 
    document.writeln("b > c");
} 
Copy
위의 모든 조건에 부합하지 않으면, "모든 조건을 만족하지 않는다." 출력합니다.
else { 
    document.writeln("모든 조건을 만족하지 않는다.");
}




/* 지시사항 1번 내용을 코드로 작성해보세요. */
var a = 20;
var b = 40;
var c = 60;

/* 지시사항 2번 내용을 코드로 작성해보세요. */
if ( a > b ) {
    document.writeln("a > b");
} 

/* 지시사항 3번 내용을 코드로 작성해보세요. */
else if ( b > c ) {
    document.writeln("b > c");
} 

/* 지시사항 4번 내용을 코드로 작성해보세요. */
else if ( a < c ) {
    document.writeln("a < c");
} 

/* 지시사항 5번 내용을 코드로 작성해보세요. */
else if ( b < c ) { 
    document.writeln("b > c");
} 

/* 지시사항 6번 내용을 코드로 작성해보세요. */
else { 
    document.writeln("모든 조건을 만족하지 않는다.");
}
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
반복문

반복문이 필요한 경우
console.log( 2 * 1 );
console.log( 2 * 2 );
console.log( 2 * 3 );
console.log( 2 * 4 );
console.log( 2 * 5 );
.
.           고정값   가변값
console.log( 2 * 9 );



- for문 - / for ( 초기화한 변수값; 조건; 증감 표시) { 수행할 명령 }

for ( var i = 0; i < 10; i++) {
    console.log(i);
}



-while 문 - / while (조건) {수행할 명령} , num <10 이 참일 동안 중괄호 안의 코드를 실행

var num = 0;

while ( num < 10) {
     console.log(num);
     num++
}




- do ~ while 문 / do { 수행할 명령 } while (조건); , while의 조건과 관계 없이 do의 명령을 무조건 실행부터 한다.

var i = 10;

do {
     console.log(i);
     i++;
} while ( i < 10);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
반복문 - while문
while문은 조건이 true이면, 명령을 계속 수행합니다.
실습을 통해 while문을 직접 만들어 봅시다!



지시사항
var num = 0;을 입력하여 변수를 생성합니다.

var num = 0;
Copy
num이 10보다 작은 경우, document.write()로 출력 후 num++ 연산을 합니다.

while (num < 10) {
        document.write(num);
        num++;
}


/* 지시사항 1번 내용을 코드로 작성해보세요. */
var num = 0;

/* 지시사항 2번 내용을 코드로 작성해보세요. */
while (num < 10) {
        document.write(num);
        num++;
}
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
반복문 - for문
for문은 while문보다 직관적으로 작성되는 반복문입니다.
실습을 통해 for문을 직접 만들어 봅시다!



지시사항
for문을 이용하여 구구단 2단을 document.write()로 출력해봅시다.

for(var i = 1; i < 10; i++) {
        document.write(2 * i);
}




/* 지시사항 내용을 코드로 작성해보세요. */

for(var i = 1; i < 10; i++) {
        document.write(2 * i);
}
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
자바스크립트 활용

주사위 게임
var dice = Math.floor ( Math.random() * 6 ) + 1;
                내림          0에서 1사이의 임의의 숫자 출력


- 소수 출력하기 -
function isPrime(n) {
   var divisor = 2;                                           2부터 나누기 시작
   while ( n > divisor) {                                    n이 나누는 수보다 클 때까지
        if ( n % divisor === 0) {                          n과 나누는 수가 나누어 떨어지면
             return false;
           } else {
             divisor++;                                        나누어 떨어지지 않는다면 나누는 수 1 증가
           }
       } return true;
   }




- 문자열 거꾸로 출력하기 - / 문자열 맨 뒤부터 출력해야 하므로 i가 0이 될 때까지 1씩 감소,
                                         인덱스는 0부터 (문자열 길이-1) 이라는 점 유의

function reverse(str){
     var reverStr = ' ';   빈 문자열
     for ( var i = str.length -1; i >= 0; i--) {
        reverStr = reverStr + str.charAt(i);         str의 i번째 문자를 빈 문자열에 추가
       } return reverStr;
   }

   console.log(reverse('Hello'));  //olleH
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
사용자가 입력한 숫자에 대응하는 구구단 만들기
for문을 사용하여 구구단의 값을 출력하는 함수 timesTable을 만들어 봅시다!
예를 들어, 함수 인자로 숫자 2가 전달되면 2단을 출력합니다.



지시사항
timeTable() 함수 안에 for문을 이용해 구구단을 출력하도록 만들어보세요.

timeTable(2)와 timeTable(3)을 호출했을 때 값이 다음과 같은 형태로 출력되어야 합니다.

2 x 1 = 2
2 x 2 = 4
...
3 x 9 = 18



function timesTable(n) {
    for(var i = 1; i < 10; i++) {
        // System.out.printIn(n+"*"+i+"="+(num*i));
        document.write(n*i)
    }
}

timesTable(2); // 2단만 출력
timesTable(3); // 3단만 출력
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
DOM과 이벤트

DOM이란?
문서 객체 모델(Document Object Model): 객체 지향 모델로써 구조화된 문서를 표현하는 형식

HTML 문서에 대한 인터페이스
DOM은 XML이나 HTML 문서의 프로그래밍 인터페이스
DOM은 문서의 구조화된 표현(structured representation)을 제공하여
프로그래밍 언어가 문서 구조, 스타일, 내용 등을 변경할 수 있도록 합니다.


HTML DOM
HTML 문서를 조작하고 접근하는 표준화된 방법
모든 HTML 요소는 HTML DOM을 통해 접근 가능


HTML -> DOM
       parsing


Document 객체
Document 객체는 웹 페이지를 의미
웹 페이지에 존재하는 HTML 요소에 접근하고자 할 때는
반드시!! Document 객체부터 시작해야 합니다.


Document 메소드
HTML 요소와 관련된 작업을 도와주는 다양한 메소드 제공
-HTML 요소의 선택
-HTML 요소의 생성
-HTML 이벤트 핸들러 추가
-HTML 객체의 선택


HTML 요소의 선택: 새로운 HTML 요소를 선택하기 위해 제공되는 메소드
document.getElementById()                해당 아이디의 요소를 선택
document.getElementByClassName()   해당 클래스에 속한 요소를 모두 선택
document.getElementByName()          해당 name 속성값을 가지는 요소를 모두 선택
document.querySelectorAll()               해당 선택자로 선택되는 요소를 모두 선택
document.querySelector()                  해당 선택자로 선택되는 요소를 1개 선택


HTML 요소의 생성: HTML 요소를 선택하기 위해 제공되는 메소드
document.createElement()   지정된 HTML 요소를 생성
document.write()                HTML 출력 스트림을 통해 텍스트를 출력


HTML 이벤트 핸들러 추가: HTML 요소에 이벤트 핸들러를 추가하기 위해 제공되는 속성
요소.onclick = function(){}    마우스 클릭 이벤트와 연결될 이벤트 핸들러


DOM의 트리 구조(HTML -> DOM)
<!DOCTYPE html>
<html>
<head>
   <title>자바스크립트 기초</title>
</head>
<body>
   <article>
      <header>header</header>
      <section>
          <header> header 1</header>
            section 1
       </section>
     </article>
</body>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
자바스크립트와 DOM

-DOM 요소의 선택-

//HTML <li> 요소를 선택
var selectedItem = document.getElementsByTagName("li");

//아이디가 "id"인 요소를 선택
var selectedItem = document.getElementById("id");

//클래스가 "odd"인 모든 요소를 선택
var selectedItem = document.getElementsByClassName("odd");

//name 속성값이 "first"인 모든 요소를 선택
var selectedItem = document.getElementsByName("first");


-DOM 요소의 스타일 변경-
//아이디가 "even"인 요소를 선택
var selectedItem = document.getElementById("ever");

//선택된 요소의 텍스트 색상을 변경
selectedItem.style.color = "red";


-DOM 요소의 내용 변경-
//아이디가 "text"인 요소를 선택
var str = document.getElementById("text");

//선택된 요소의 내용을 변경
str innerHTML = "요소의 내용을 바꿉니다";
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
DOM 요소의 선택
DOM은 문서의 구조화된 표현(structured representation)을 제공하여
프로그래밍 언어가 문서 구조, 스타일, 내용 등을 변경할 수 있도록 합니다.
먼저 DOM을 이용하여 HTML의 요소를 선택해봅시다!

document.getElementsByTagName();  // 태그 이름 선택
document.getElementById();   // 아이디 선택
document.getElementsByClassName();   //클래스 선택
document.getElementsByName();  // name 속성값 선택
Copy


지시사항
document.getElementsByTagName()를 사용하여 태그가 div인 요소를 선택합니다.
var selectedTagName = document.getElementsByTagName("div"); 
Copy
document.getElementById()를 사용하여 아이디가 banana인 요소를 선택합니다.
var selectedId = document.getElementById("banana");
Copy
document.getElementsByClassName()를 사용하여 클래스가 vegetable인 모든 요소를 선택합니다.
var selectedClassNameS = document.getElementsByClassName("vegetable"); 
Copy
document.getElementsByName()를 사용하여 name 속성값이 red인 모든 요소를 선택합니다.
var selectedNameS = document.getElementsByName("red"); 



// HTML <div> 요소를 선택하도록 코드를 작성하세요
var selectedTagName = document.getElementsByTagName("div");

// 아이디가 “banana"인 요소를 선택하도록 코드를 작성하세요
var selectedId = document.getElementById("banana");

// 클래스가 "vegetable"인 모든 요소를 선택하도록 코드를 작성하세요
var selectedClassNameS = document.getElementsByClassName("vegetable"); 

// name 속성값이 "red"인 모든 요소를 선택하도록 코드를 작성하세요
var selectedNameS = document.getElementsByName("red"); 


// 선택된 요소들을 출력합니다.
document.write(selectedTagName);
document.write(selectedId);
document.write(selectedClassNameS);
document.write(selectedNameS);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
DOM 요소의 스타일 변경
DOM은 문서의 구조화된 표현(structured representation)을 제공하여
프로그래밍 언어가 문서 구조, 스타일, 내용 등을 변경할 수 있도록 합니다.
이번엔 DOM을 이용하여 요소의 스타일을 변경해봅시다!

selectedItem.style.color ="변경할 내용" // 선택된 요소의 색깔을 바꿉니다.
Copy


지시사항
실행 버튼을 눌러 모든 글자가 검은색으로 되어 있음을 확인한 뒤, 5, 17번째 줄에 작성된 코드의 주석을 해제합니다.

document.getElementById()를 사용하여 아이디가 apple인 요소를 선택합니다.

var selectedId = document.getElementById("apple");
Copy
selectedItem.style.color를 사용하여 선택한 요소의 색깔을 red로 바꿔줍니다.

selectedId.style.color = "red";  
Copy
document.getElementById()를 사용하여 아이디가 banana인 요소를 선택합니다.

var selectedId = document.getElementById("banana");
Copy
selectedItem.style.color를 사용하여 선택한 요소의 색깔을 yellow로 바꿔줍니다.

selectedId.style.color = "yellow";



// 밑의 주석을 해제하지 말고 먼저 실행해서 초기 상태를 확인하세요

// 초기 상태를 확인한 다음엔 주석을 해제해주세요


// 아이디가 "apple"인 요소를 선택하도록 코드를 작성하세요
var selectedId = document.getElementById("apple");

// 선택한 요소의 색깔을 red로 바꿉니다.
selectedId.style.color = "red";   

// 아이디가 "banana"인 요소를 선택하도록 코드를 작성하세요
var selectedId = document.getElementById("banana");

// 선택한 요소의 색깔을 yellow로 바꿉니다.
selectedId.style.color = "yellow";
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
DOM 요소의 내용 변경
DOM은 문서의 구조화된 표현(structured representation)을 제공하여
프로그래밍 언어가 문서 구조, 스타일, 내용 등을 변경할 수 있도록 합니다.
이번엔 DOM을 이용하여 요소의 내용을 변경해봅시다!

selectedItem.innerHTML = "변경할 내용"// 선택된 요소의 내용을 바꿉니다.
Copy


지시사항
실행 버튼을 눌러 초기 내용을 확인한 뒤, 5, 17번째 줄에 작성된 코드의 주석을 해제합니다.

document.getElementById()를 사용하여 아이디가 apple인 요소를 선택합니다.

var selectedId = document.getElementById('apple');

selectedItem.innerHTML를 사용하여 선택한 요소의 내용을 strawberry로 바꿔줍니다.

selectedId.innerHTML = 'strawberry'; 

document.getElementById()를 사용하여 아이디가 onion인 요소를 선택합니다.

var selectedId = document.getElementById('onion');

selectedItem.innerHTML를 사용하여 선택한 요소의 내용을 garlic으로 바꿔줍니다.

selectedId.innerHTML = 'garlic'; 



// 밑의 주석을 해제하지 말고 먼저 실행해서 초기 상태를 확인하세요

// 초기 상태를 확인한 다음엔 주석을 해제해주세요


// 아이디가 "apple"인 요소를 선택하도록 코드를 작성하세요
var selectedId = document.getElementById('apple');

// 선택한 요소의 내용을 "strawberry"로 바꿉니다.
selectedId.innerHTML = 'strawberry'; 

// 아이디가 "onion"인 요소를 선택하도록 코드를 작성하세요
var selectedId = document.getElementById('onion');

// 선택한 요소의 내용을 "garlic" 바꿉니다.
selectedId.innerHTML = 'garlic'; 
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Node 객체

---노드(Node) 와 노드 트리---

HTML DOM에서 정보를 저장하는 계층적 단위

노드 트리는 노드들의 집합으로,
노드 간의 관계를 나타낸다.

자바스크립트에서는
HTML DOM을 이용하여 노드 트리에 포함된 모든
노드에 접근할 수 있다.



---노드 간의 관계 ---
노드 트리의 모든 노드는 서로 계층적 관계를 맺고 있습니다

루트 노트                <- 부모 노드 -------------
HTML

          첫번째 자식 노드 -> HEAD
                              
                                      형제노드

          두번째 자식 노드  ->  BODY     ---------




---노드의 종류---
문서 노드(document node) - HTML 문서 전체를 나타내는 노드
요소 노드(element node) - 모든 HTML 요소는 요소 노드로, 속성 노드를 가질 수 있는 유일한 노드
주석 노드(comment node) - HTML 문서의 모든 주석은 주석 노드
속성 노드(attribute node) - 모든 HTML 요소의 속성은 속성 노드이며, 요소 노드에 관한 정보를 가진다.
                                     하지만 해당 요소 노드의 자식 노드(child node)에는 포함되지 않는다.
텍스트 노드(text node) - HTML 문서의 모든 텍스트는 텍스트 노드


---노드의 값---
노드에 대한 정보는 다음과 같은 프로퍼티를 통해 접근할 수 있습니다
nodeName (이름), nodevalue (값), nodeType (타입)

//HTML 문서의 모든 자식 노드 중에서 첫 번째 노드의 이름을 선택
document.childNodes[0].nodeName;

//아이디가 "heading"인 요소의 첫 번째 자식 노드의 노드값을 선택
document.getElementById("heading").firstchild.nodeValue;

//아이디가 "heading"인 요소의 첫 번째 자식 노드의 타입을 선택
document.getElementById("heading").firstChild.nodeType;
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
노드의 값 접근 (이름)
자바스크립트에서는 HTML DOM을 이용하여 노드 트리에 포함된 모든 노드에 접근할 수 있습니다
먼저 DOM을 이용하여 노드의 이름에 접근해봅시다.

childNodes[0].nodeName;  // 자식 노드 중에서 첫 번째 노드의 이름을 선택
Copy



지시사항
document.childNodes[1]를 사용하여 document 의 자식 노드들 중 두 번째 노드를 node1변수에 할당합니다.

var node1 = document.childNodes[1];
Copy
node1.childNodes[2]를 사용하여 node1의 자식 노드들 중 세 번째 노드를 node2변수에 할당합니다.

var node2 = node1.childNodes[2];
Copy
같은 방식으로 node2의 자식 노드들 중 두 번째 노드를 node3변수에 할당합니다.

var node3 = node2.childNodes[1];
Copy
node1, node2, node3의 이름을 nodeName을 이용해 출력합니다.

document.write(node1.nodeName);
document.write(node2.nodeName);
document.write(node3.nodeName);
Copy
console.log() 를 이용해 node2의 자식 노드들의 값을 모두 확인해봅시다.

console.log(node2.childNodes);



// 1. document 의 자식 노드들 중 두번째 노드를 node1변수에 할당하도록 코드를 작성하세요.
var node1 = document.childNodes[1];

// 2. node1의 자식 노드들 중 세번째 노드를 node2변수에 할당하도록 코드를 작성하세요.
var node2 = node1.childNodes[2];

// 3. node2의 자식 노드들 중 두번째 노드를 node3변수에 할당하도록 코드를 작성하세요.
var node3 = node2.childNodes[1];

// 4. node1, node2, node3의 이름을 nodeName을 이용해 출력하도록 코드를 작성하세요.

document.write(node1.nodeName);
document.write(node2.nodeName);
document.write(node3.nodeName);

//5. `node2`의 자식 변수들을 모두 출력해봅니다.
console.log(node2.childNodes);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
노드의 값 접근 (값)
자바스크립트에서는 HTML DOM을 이용하여 노드 트리에 포함된 모든 노드에 접근할 수 있습니다
이번엔 DOM을 이용하여 노드의 값에 접근해봅시다.

firstChild.nodeValue;  // 첫 번째 자식 노드의 값을 선택
Copy



지시사항
실행 버튼을 눌러 초깃값을 확인합니다.

주석을 제거하고 document.getElementById()를 사용하여 아이디가 apple인 요소를 선택하여 apple_node변수에 할당합니다.
var apple_node = document.getElementById("apple");


node.firstChild.nodeValue를 사용하여 node의 첫 번째 자식 노드의 값을 apple_pie로 변경합니다.
apple_node.firstChild.nodeValue = "apple_pie";

실행 버튼을 눌러 바뀐 값을 확인합니다.


// 먼저 실행 버튼을 눌러 초기 값을 확인하세요

// 초기 값을 확인한 뒤, 주석을 지워주세요.
// 1. document.getElementById()를 사용하여 아이디가 apple인 요소를 선택하도록 코드를 작성하세요.
var apple_node = document.getElementById("apple");

// 2. firstChild.nodeValue를 사용하여 node의 첫번째 자식 노드의 값을 `apple_pie`로 변경하도록 코드를 작성하세요.
apple_node.firstChild.nodeValue = "apple_pie";

// 3. 실행 버튼을 눌러 바뀐 값을 확인합니다..
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
노드의 값 접근 (타입)
자바스크립트에서는 HTML DOM을 이용하여 노드 트리에 포함된 모든 노드에 접근할 수 있습니다.
이번엔 DOM을 이용하여 노드의 타입에 접근해봅시다.
childNodes[0].nodeType;  // 자식 노드 중에서 첫 번째 노드의 이름을 선택

nodeType 프로퍼티 값
nodeType 프로퍼티 값은 텍스트가 아닌 숫자로 표현됩니다.
대표적인 HTML 노드별 nodeType 프로퍼티 값은 다음과 같습니다.

요소 노드:1
속성 노드: 2
텍스트 노드: 3
주석 노드: 8
문서 노드: 9



지시사항
getElementById, childNodes를 사용하여 아이디가 apple인 요소의 첫 번째 자식 노드를 apple_node변수에 할당합니다.

var apple_node = document.getElementById('apple').childNodes[0];

nodeValue을 사용하여 apple_node의 값을 apple_node_value변수에 할당합니다

var apple_node_value = apple_node.nodeValue;

nodeType을 사용하여 apple_node의 타입을 apple_node_type변수에 할당합니다

var apple_node_type = apple_node.nodeType;

apple_node_value와 apple_node_type를 출력합니다.

document.write(apple_node_value+'\n');
document.write(apple_node_type);



// 1. 아이디가 apple인 요소의 첫번째 자식 노드를 선택하도록 코드를 작성하세요.
var apple_node = document.getElementById('apple').childNodes[0];

// 2. apple_node의 값을 변수에 할당하도록 코드를 작성하세요.
var apple_node_value = apple_node.nodeValue;

// 3. apple_node의 타입을 변수에 할당하도록 코드를 작성하세요.
var apple_node_type = apple_node.nodeType;

// 4. apple_node의 값과 타입을 출력하도록 코드를 작성하세요.
document.write(apple_node_value+'\n');
document.write(apple_node_type);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
이벤트(Event)란?
어떠한 사건의 발생 - 웹 브라우저가 알려주는 HTML 요소에 대한 사건의 발생,
                             자바스크립트는 발생한 이벤트에 반응하여 특정 동작을 수행할 수 있다.

---이벤트 타입---
발생한 이벤트의 종류 (폼, 키보드, 마우스, HTML DOM, Window 객체 등)

//마우스 클릭 이벤트 예시
<p onclick="changeText(this)">여길 클릭하세요!</p>

<script>
function changeText(element) {
     element.innerHTML = "내용이 바뀌었습니다!";
}
</script>



---이벤트 핸들러---
이벤트가 발생했을 때 그 처리를 담당하는 함수
지정된 이벤트가 발생하면, 웹 브라우저는 그 요소에 등록된 이벤트 핸들러를 실행시킵니다

//이 함수는 HTML 문서가 로드될 때 실행됨.
window.onload = function() {

      // 아이디가 "text"인 요소를 선택함.
      var text = document.getElementById("text);

      text.innerHTML = "HTML 문서가 로드되었습니다.";
}
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>자바스크립트 기초</title>
</head>
<body>

    <div name="text"  class="text" id="text">NULL</div>
    <button onclick="this.innerText ='성공입니다!'">클릭하세요!</button>

<script src="index.js"></script>
  
</body>
</html>




지시사항
자바스크립트 코드에서 등록
index.js 파일을 여세요.

window.onload를 사용하여 HTML 문서가 로드될 때 이벤트 핸들러가 작동하도록 해보세요.

페이지가 열렸습니다 문구를 띄우는 함수를 작성하세요.

getElementById()를 사용하여 아이디가 text인 요소를 선택한 뒤, innerHTML를 이용해 선택한 요소의 내용을 페이지가 열렸습니다 로 바꿔보세요.

window.onload = 

   function() {
     var text = document.getElementById("text");
     text.innerHTML = "페이지가 열렸습니다";
    };
Copy
HTML 태그에서 등록
index.html 파일을 여세요.

onclick을 사용하여 클릭하세요! 문구를 클릭하면 성공입니다! 문구로 바뀌도록 만들어 보세요.

<button onclick="this.innerText ='성공입니다!'">클릭하세요!</button>



//  window.onload를 사용하여 HTML 문서가 로드될 때 이벤트 핸들러가 작동하도록 해보세요.
window.onload = 

   function() {
     var text = document.getElementById("text");
     text.innerHTML = "페이지가 열렸습니다";
    };
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
이벤트 핸들러 2
이벤트란 웹 브라우저가 알려주는 HTML 요소에 대한 사건의 발생을 말합니다.
자바스크립트는 발생한 이벤트에 반응하여 특정 동작을 수행할 수 있습니다.
객체나 요소의 메서드에 이벤트 핸들러를 전달할 때는 다음 메서드를 사용할 수 있습니다.
addEventListener()


addEventListener 사용법
대상객체.addEventListener(이벤트명, 실행할이벤트핸들러, 이벤트전파방식)



지시사항
아이디가 carrot인 요소를 선택하세요

var carrot_btn = document.getElementById("carrot"); 
Copy
클릭할 시 텍스트를 보여주는 showText함수를 작성합니다.
버튼을 클릭하면 아이디가 text인 요소의 내용을 토끼가 나타났어요!! 문장으로 출력하도록 해보세요.

function showText() {
    document.getElementById("text").innerHTML = "토끼가 나타났어요!!";
};
Copy
addEventListener를 사용하여 "click"이벤트명을 가진 이벤트 핸들러를 등록하세요.

carrot_btn.addEventListener("click", showText);




// 1. 아이디가 "carrot"인 요소를 선택하세요
var carrot_btn = document.getElementById("carrot"); 

// 2. click 할 시 텍스트를 보여주는 함수를 작성합니다.
//    버튼을 클릭하면 "토끼가 나타났어요!!" 문장을 출력하도록 해보세요

function showText() {
    document.getElementById("text").innerHTML = "토끼가 나타났어요!!";
};

// 3. 선택한 요소에 "click" 이벤트 핸들러를 등록하세요 (이벤트명:"click", 함수이름)
carrot_btn.addEventListener("click", showText);   
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
누르면 바뀌게
버튼을 클릭하면 그 버튼이 클릭되었다는 것을 알 수 있도록 색상과 이름을 변경해봅시다.


지시사항
버튼 클릭 시 색상이 변경될 수 있도록 changeColor 클래스를 추가하세요.
버튼 클릭 시 innerText 메소드를 사용해 버튼의 타이틀이 ‘버튼 클릭 성공!’으로 변경될 수 있도록 작성해주세요.
버튼 클릭 시 위의 함수changeButtonOnclick가 실행될 수 있도록 작성해주세요.


---js---
/*지시사항을 따라 작성해주세요*/
var target = document.getElementById("btn");

function changeButtonOnclick() {
  /*지시사항 1번*/
target.classList.add("changeColor")
  /*지시사항 2번*/
target.innerText = "버튼 클릭 성공!"
}

/*지시사항 3번*/
target.addEventListener("click", changeButtonOnclick)



---css---
button {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  
  padding: 10px;
  background-color: white;
  
  border: none;
  border-radius: 4px;
  
  display: inline-block;
  
  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
  
  cursor: pointer;
  
  transition: 0.5s;
}

button:hover { color:grey; }

body {
  background: #eee;
  justify-content: center;
  align-items: center;
  display: flex;
  height: 100px;
}

.changeColor { background-color: lightblue; }



---html---
<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>누르면 바뀌게</title>
  <link rel="stylesheet" type="text/css" href="index.css">  
</head>

<body>
  <button id="btn">버튼을 눌러주세요</button>
</body>
<script src="index.js"></script>
</html>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Node.js 와 Express.js


---Node.js이해---


WEB 1.0                ->            WEB 2.0                        ->         
                                                                    고성능의 JavaScript 필요
단방향 통신 위주                 사용자와 상호작용                                            V8 엔진 등장



V8 - 고성능 JavaScript 실행 가능

JavaScript를 브라우저 외부에서 사용해볼까? - Node.js 탄생

Node.js는 자바스크립트를 어느 환경에서나 실행할 수 있게 해주는 실행기



--Node.js vs Browser--

-Browser의 JavaScript-
브라우저에서 실행
웹 내부 제한된 동장
웹 프론트 개발자의 언어

-node.js-
크로스 플랫폼 실행
제한 없는 동작
다양한 어플리케이션 개발


Node.js 로 할 수 있는 것들
Front-End : React.js                 최근 가장 인기 있는 웹서비스 구성
Back-End : Express.js                최근 가장 인기 있는 웹서비스 구성
Mobile-App : React-Native        한가지 코드로 IOS와 Android 개발
Desktop-App : Electron             Discord Slack등 앱 개발
Machine-Learning : Brain.js         JavaScript로 구현하는 딥러닝
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
--Node.js의 특징--
싱글 쓰레드 - 비동기 - 이벤트 기반

쓰레드란?
쓰레드는 명령을 실행하는 단위
한 개의 쓰레드는 한 번에 한 가지 동작만 실행 가능


싱글 쓰레드와 멀티 쓰레드의 차이점

싱글 쓰레드 - 한 번에 한가지 동작만 수행함
동작1   동작2   동작3


멀티 쓰레드 - 동시에 여러 동작 수행 가능

쓰레드1
동작1
쓰레드2
동작2
쓰레드3
동작3


그렇다면 쓰레드는 안 좋은 것 아닌가요?
장점 - 쓰레드가 늘어나지 않기 때문에 리소스 관리에 효율적
단점 - 쓰레드 기반의 작업들의 효율이 떨어짐 Ex) CPU 연산 작업
그래서 Node.js 는 비동기 동작으로 쓰레드 기반의 작업을 최소화합니다.


비동기란?
동작을 실행한 후 완료가 되길 기다리지 않는 방식
동작의 완료를 기다리지 않기 때문에 다른 동작을 바로 실행 가능
Node.js 는 싱글 쓰레드이기 때문에 비동기 방식을 사용함


동기와 비동기의 차이

멀티 쓰레드 동기 방식             실행     CPU 리소스 낭비    완료

싱글 쓰레드 비동기 방식           외부 작업. Ex) 데이터베이스 쿼리


이벤트 기반이란?
비동기 동작의 완료를 처리하는 방법
비동기 방식은 특정 동작을 실행한 후, 해당 동작을 전혀 신경 쓰지 않음
대신 해당 동작이 완료될 경우 실행할 함수를 미리 등록함
비동기 동작이 완료가 되면 미리 등록된 함수를 실행


이벤트 기반
                                     외부 작업. Ex) 데이터베이스 쿼리
이벤트 등록 - 하고 - 전달 - 하고 - 전달 ................... 완료 - 완료 - 완료 - 이벤트 실행

                                     이벤트 기반 동작 방식


Node.js의 특징 요약
싱글 쓰레드이기 때문에 비동기 동작 필요
비동기 동작을 구현하기 위해 이벤트 기반
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
다음 중 Node.js 에대한 설명으로 올바르지 않은 것은?
싱글쓰레드 기반이다.
서버개발 전용 런타임이다. X
이벤트 기반 동작을 사용한다.
비동기 동작을 기본으로 한다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Node.js 시작하기

어떤 버전으로 시작해야 할까?
V8 -> Node.js 설치

-Node.js는 빠르게 개발 중-
보안 이슈 및 버그 수정, 최신기술 빠르게 적용
급변하는 기술은 가장 안정적인 최신 버전을 선택하는 것이 최선

-LTS-
Long-Term Support 버전
Node.js의 안정적이고, 오래 지원하는 버전 명


어떤 버전으로 시작해야 할까?
16.13.0 LTS - 안정적, 신뢰도 높음(본 강의 기준버전)

17.0.1 현재 버전 - 최신 기능

안정적이고 오래 지원되는 버전 vs 가장 최신기술이 적용된 버전
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
용돈 압수
엘리스 토끼는 하루에 용돈 500원을 받습니다.
하지만 숙제를 안 하고 놀러 다닌 엘리스는 용돈을 받지 못하게 되었습니다.

money 문자열에서 "500원"을 기준으로 문자열을 나누어 리스트로 반환해봅시다.


지시사항
money 문자열에서 "500원"을 기준으로 나누어 배열 형태로 저장하세요.
저장한 배열을 출력하세요.


// money 문자열입니다.
var money = "500원, 엘리스 토끼는 하루 용돈으로 500원. 단돈 500원을 받는다. 부모님이 주시는 500원. 하지만 잘못한 것이 있으면 500원을 받지 못한다.";

// 지시사항을 참고하여 코드를 작성하세요.
var splitted_money = money.split("500원")

console.log(splitted_money)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Node.js와 Express.js

---ES6---
ECMAScript 버전 6 이후를 통틀어 일반적으로 ES6라고 부름

---ECMAScript---
계속해서 발전해가는 JavaScript의 표준문법
2015년, ECMAScript 버전 6 이후로 많은 현대적인 문법이 추가됨

---ES6을 사용하는 이유?---
현대적인 문법은 생산성 향상에 도움을 줌
Node.js는 빠르게 최신 ECMAScript를 지원 중
자주 사용되는 유용한 문법을 익히고 필요한 부분에 적절하게 활용하는 것이 중요

Node.js는 ES6의 모든 문법을 지원하지는 않음
Node.js로 자주 사용되는 유용한 ES6문법의 코드를 실행해보며
Node.js와 친숙한 시간을 가지자.

---자주 사용되는 문법 1 - let, const---

-기존 문법-
// 상수와 변수 구분이 없음
var TITLE = 'NODE.JS';
var director = 'elice';
director = 'rabbit';
TITLE = 'ES6' // 오류 없음

-ES6-
// 상수와 변수 구분 가능
const TITLE = 'NODE>JS';
let director = 'elice';
director = 'rabbit';
TITLE = 'ES6'; // 오류 발생



---자주 사용되는 문법 2 - Template String---

-기존 문법-
var name = 'elice';
var age = 5;
//+를 사용해 문자열과 변수 연결
//줄 바꿈 문자 \n 사용 필요
var hi = 'My name is '
    + name
    + '.\n I\'m '
    + age
    + 'years old. ';
console.log(hi);


-ES6-
const name = 'elice';
const age = 5;
//문자열 사이에 간단하게 변수 사용 가능
//따옴표 간단하게 사용 가능
//줄 바꿈 지원

const hi = 
    'My name is ${name}
    I'm ${age} years old';
   console.log(hi);


---자주 사용되는 문법 3 - arrow function---


-기존 문법-
//기본 함수 표현 방법
function doSomething(param) {
 console.log('do something');
}

//익명 함수 표현 방법
setTimeout(function(param) {
console.log('no name function');
}, 0)

//함수 새로 선언 가능
function doSomething ( ) {
console.log('do other');
}


-ES6-
//상수형으로 표현 가능
const doSomething = (param) => {
console.log('do something');
}

//익명함수 간결하게 표현 가능
setTimeout((param) => {
console.log('no name function');
}

//함수 새로 선언 불가능
doSomething = ( ) => {
console.log('do other');
}


---자주 사용되는 문법 4 - class---


-기존 문법-
function Model(name, age) {
this.name = name;
this.age = age;
}
//prototype으로 class 함수 구현
Model.prototype.getInfo = function () {
console.log(this.name, this.age);
}
var model = new Model('elice', 5);
model.getInfo();

-ES6-
//일반적인 형태의 class 구현 가능
class Model {
constructor(name, age) {
this.name = name;
this.age = age;
}
getInfo() {
console.log(this.name, this.age);
}
}
const model = new Model('elice', 5);
model.getInfo();


---자주 사용되는 문법 5 - destructing---

-기존 문법-
var obj = {name: 'elice', age: 5};
var name = obj.name;
var age = obj.age;

var arr = ['some', 'values'];
var first = arr[0];
var second = arr[1];

-ES6-
const obj = {name: 'elice', age: 5};
//Object의 key와 같은 이름으로 변수 선언 가능
const { name, age } = obj;
//다른 이름으로 변수 선언하는 방법

const arr = ['some', 'values'];
//arr에서 순차적으로 변수 선언 가능
const [first, second] = arr;


---자주 사용되는 문법 6 - promise, async-await---
Promise와 Async -Await은 간단한 요약이 어려움
다음 장에서 비동기 코딩과 함께 학습합니다.


---ES6 적용 결과---
복잡하거나 직관적이지 않던 방법을
보기 좋게 만들고 간결하게 표현할 수 있게 됨.
현대적인 문법은 처음 접할 땐 어색하지만,
익숙해지면 좋은 코드를 작성할 수 있게 됨.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
ES6 let, const 사용하기
ES6의 let과 const를 사용해 봅니다.


지시사항
variable은 언제든 변경이 가능한 변수로,
constant는 변경이 불가능한 상수로 사용려고 합니다.
각각의 선언문을 let과 const를 적절히 활용하여 수정해 봅시다.

variable 변수를 let을 이용해 변경이 가능한 변수로 선언하도록 수정합니다.
let variable = 1;
Copy
constant 변수를 const를 이용해 변경이 불가능한 상수로 선언하도록 수정합니다.
const constant = 2;



/* 지시사항의 내용을 따라 아래 코드를 수정해보세요. */
let variable = 1;
const constant = 2;

console.log('variable', 1);
console.log('constant', 2);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
ES6 Template String 사용하기
다음은

Cat has 4 legs.
Cat says "meow".
Copy
라는 문자열을 출력하는 프로그램입니다.
지시사항에 따라 ES6의 Template String을 사용해 봅니다.


const animal = 'Cat';
const legs = 4;
const sound = 'meow';

/* 지시사항의 내용을 따라 아래 코드를 수정해보세요. */
const explain = animal 
    + ' has ' 
    + legs 
    + ' legs.\n' 
    + animal 
    + ' says \"' 
    + sound 
    + '\".';
    
console.log(explain);
ㅡㅡㅡ

const animal = 'Cat';
const legs = 4;
const sound = 'meow';

/* 지시사항의 내용을 따라 아래 코드를 수정해보세요. */
const explain = `${animal} has ${legs} legs.
                ${animal} says "${sound}".
            `;
    
console.log(explain);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
ES6 arrow function 사용하기
ES6의 arrow function 표현을 사용해 봅니다.

다음은 두 숫자가 주어졌을 때, 두 숫자의 덧셈을 출력하는 프로그램의 일부입니다.
add 함수는 숫자의 합을 a+b=c의 형태인 문자열로 만들어 주는 함수입니다.
코드를 실행하면 add 함수를 세번 수행하도록 구성되어 있습니다.
지시사항에 맞게 주어진 함수를 수정해 봅니다.


지시사항
function add ...로 선언된 add 함수를 arrow function 표현법으로 재작성해 봅니다.

-arrow function을 사용하여 함수를 선언합니다.
-함수는 const add로 선언합니다.
-주어진 함수와 동일한 동작을 하도록 수정합니다


/* 지시사항의 내용을 따라 아래 코드를 수정해보세요. */
function add(a, b) {
    return `${a}+${b}=${a+b}`;
}

module.exports = add;
ㅡㅡㅡ

const add = (a, b) => {
    return `${a}+${b}=${a+b}`;
}
module.exports = add;
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
ES6 class 사용하기
ES6의 class를 사용해 봅니다.

다음은 ES6의 class를 활용하여 동물을 소개하는 프로그램의 일부입니다.
주어진 지시사항을 만족하는 코드를 완성 시켜 봅니다.


지시사항
Animal 클래스의 explain() 함수가 동작할 수 있도록 constructor를 완성하고, Animal 클래스를 사용하여 duck 객체를 생성해 봅니다.

-constructor에 알맞은 코드를 작성하여 explain() 함수가 동작할 수 있도록 합니다.
this.name = name;
this.sound = sound;

-const duck 변수에 name은 “duck”, sound는 “quack”으로 duck 객체를 생성합니다.
const duck = new Animal("duck", "quack");



class Animal {
    constructor(name, sound) {
        /* 지시사항 1번 내용을 코드로 작성해보세요. */
    this.name = name;
    this.sound = sound;
    }
    
    explain() {
        console.log(`${this.name} says ${this.sound}`)
    }
}

/* 지시사항 2번 내용을 코드로 작성해보세요. */
const duck = new Animal("duck", "quack");

module.exports = duck;
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
ES6 destructing 사용하기
ES6 desctructing을 사용해 봅니다.

다음은 오브젝트와 배열의 값을 다른 변수로 저장하는 예제입니다.
주어진 지시사항을 만족하도록 코드를 수정해 봅니다.


const duck = {
    name: "duck",
    sound: "quack",
};

/* 지시사항 1번 내용을 따라 코드를 수정해보세요. */
const {name:duckName, sound: duckSound
} = duck;

console.log("name", duckName);
console.log("sound", duckSound);

const animals = ["duck", "cat", "bear"];


/* 지시사항 2번 내용을 따라 코드를 수정해보세요. */
const [first, second, third] = animals;

console.log("first", first);
console.log("second", second);
console.log("third", third);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
비동기 코딩

비동기 - 이벤트 기반 동작을 코드로 구현하는 방법
Node.js 에서 비동기 동작을 구현하는 세 가지 방법을 학습


---비동기 코딩의 세가지 방법---

Callback
전통적인 JavaScript의 이벤트 기반 코딩 방식

Promise
callback의 단점을 보완한 비동기 코딩 방식

Async - Await
promise의 단점을 보완한 비동기 코딩 방식


---Callback---
get-users.js

db.getUsers((err, users) => {
console.log(users);
});

-비동기 동작
db.getUsers 함수는 데이터베이스에서 유저
목록을 찾아오는 비동기 동작을 수행

-이벤트 등록/실행
쿼리가 완료되면 오류가 있는지, 혹은
유저목록의 결과로 미리 등록된 callback
함수를 실행

- 참고 - callback의 표준
에러와 결과를 같이 전달하는 것이 표준으로
자리 잡혀 있음

---콜백 지옥---
callback-hell.js

db.getUsers((err, users) => {
 if (err) {
   ...
   return;
}
async1(users, (r1) => {
async2(r1, (r2) => {
async3(r2, (r3) => {
   ...
});
});
});
});

-async1, async2, async3 ... 를 동기적으로
실행해야 할 경우?
Node.js는 기본적으로 비동기 동작을
callback으로 처리하기 때문에 계속해서
callback의 callback의 callback의
callback

코드가 좋아 보이나요?


---Promise의 등장---
use-promise.js

db.getUsersPromise()
  .then((users) => {
     return promise1(users);
  })
   .then(r1 => promise2(r1))
   .catch(...);

-Promise 함수는 동작이 완료되면 then에
등록된 callback 실행.
오류가 발생한 경우 catch 에 등록된 callback
실행.
Chaining을 사용해 코드를 간결하게
Short-hand 표현 방법으로 더욱 간결하게
1. Return 생략 가능
2. 인자가 하나인 경우 () 생략 가능


---Async - Await의 등장 ---

async function doSomething() => {
   cosnt r1 = await promise1();
   cosnt r2 = await promise1(r1);
   cosnt r3 = await promise1(r1, r2);
   ...
   return r3;
});

doSomething().then(r3 => {
   console.log(r3)
});

ㅡㅡㅡ
async-await 은 promise의 다른 문법

async 함수 내에서 promise 함수의 결과는
await 으로 받을 수 있음.
await 한 promise 함수가 완료될 때 까지
다음 라인으로 넘어가지 않음.

순차적 프로그래밍처럼 작성 가능.

async 함수의 return 은 Promise


---Async 함수의 오류처리---
동일한 동작을 하는 promise 함수와 async 함수

-promise 오류 처리-
function doSomething(msg) {
  return promise1()
    .then(r => {
      console.log(r)
    })
     .catch(e => {
       console.error(e)
     });
}


-async 오류 처리-
async function doSomething(msg) {
   try {
      const r = await promise1();
      console.log(r);
    } catch(e)  {
      console.error(e);
    }
}



---Promise 의 병렬 실행---


--- 비동기 코딩 정리 ---

callback 지옥 -> promise chaining으로 해결
promise 지옥 -> async - await으로 해결

현대 JavaScript에서는 대부분 가독성이 좋은 async - await을 지향하지만,
특정 상황에 맞는 비동기 코딩 방법들을 구사할 줄 알아야 함.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
callback 사용하기
다음은 주어진 시간을 초 단위로 카운트다운 한 후 callback 함수를 실행하는 코드의 일부입니다.
지시사항을 만족하도록 코드를 완성 시켜 봅니다.


지시사항
countDown(count, callback) 함수는 count 값을 초 단위로 카운트 다운한 후 callback 함수를 실행하는 함수입니다.

-5초 후에 callback이 실행되도록 수정합니다.
-callback은 “BOOM!”이라는 문자열이 출력되는 함수로 구성 합니다. 출력은 console.log 함수를 사용합니다.
-함수는 ES6의 arrow function을 사용합니다.



const countDown = require('./countdown');

/* 지시사항의 내용을 코드로 작성해보세요. */

countDown(5, () => {
    console.log("BOOM!")
});
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
promise의 작성과 사용
callback 함수로 작성된 코드를 promise로 작성하여 사용해 봅니다.

callback.js는 콜백을 활용하여 세 값을 더하는 기능을 구현한 프로그램의 일부입니다.
callback-hell에서 벗어나기 위해 이 함수를 promise로 재작성하려고 합니다.
callback.js를 참고하여 지시사항을 만족하는 promise.js를 완성해 봅니다.



지시사항
promise.js 파일을 다음 지시사항을 만족하도록 수정합니다.
adder(a, b, callback) 함수를 promise로 재작성한 함수 adder_promise를 완성합니다.


callback 함수 실행 오류를 promise로 처리합니다.
reject(err);


callback 함수 실행 결과를 promise로 처리합니다.
resolve(a + b);


callback.js 파일을 참고하여 add_all() 함수 내 adder_promise(a, b)의 다음 줄을 완성합니다.
.then(result => {
        return adder_promise(result, c)
})


catch를 활용하여 promise 에러를 handle_error 함수로 처리하도록 완성합니다.
.catch(
    error => handle_error(error)
)
ㅡㅡㅡ



function adder(a, b, callback) {
    if (a == 0 || b == 0) {
        callback("no zero", null);
        return;
    }
    console.log(`${a}+${b}=${a + b}`);
    
    callback(null, a + b);
}

function handle_error(error) {
    console.log("ERROR: ", error);
}

function adder_promise(a, b) {
    return new Promise((resolve, reject) => {
        adder(a, b, (err, result) => {
            if (err) {
                /* 1. promise 에서 에러 처리하기 */
                reject(err);
                return;
            }
            /* 2. promise 에서 결과값 처리하기 */
            resolve(a + b);
        });
    });
}

function add_all(a, b, c) {
    adder_promise(a, b)
        /* 3. then 을 활용하여 result 와 c 를 add_promise 하기 */
        .then(result => {
        return adder_promise(result, c)
})
        .then(result2 => {
            console.log(`${a}+${b}+${c}=${result2}`);
        })
        /* 4. catch 를 활용하여 promise 의 에러를 handle_error 함수로 전달하기 */
        .catch(
    error => handle_error(error)
)
}

module.exports = add_all;
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
async - await 사용하기
adder_promise는 두 값을 더한 결과를 promise로 전달하는 함수입니다.



지시사항
main_promise 함수의 동작을 참고하여 main 함수를 완성합니다.

async, await을 적절하게 활용합니다.

main 함수를 async 함수로 선언하도록 수정합니다.
adder_promise(a, b)와 adder_promise(c, d)를 동시에 실행하고 결과를 각각 r1과 r2에 저장합니다.
r1과 r2를 한 번 더 adder_promise 함수에 전달하고 결과를 r3에 저장합니다.



const adder_promise = require('./promise');

function main_promise(a, b, c, d) {
    Promise.all([
        adder_promise(a, b),
        adder_promise(c, d),
    ])
    .then(([r1, r2]) => {
        return adder_promise(r1, r2);
    })
    .then((r3) => {
        console.log(`${a}+${b}+${c}+${d}=${r3}`);
    });
}

/* 1. main 을 async 함수로 선언 */
async function main(a, b, c, d) {
    const [r1, r2] = await promise.all([
        adder_promise(a, b),
        adder_promise(c, d),
    ]);
    const r3 = await adder_promise(r1, r2);
    console.log(`${a}+${b}+${c}+${d}=${r3}`);
}

main(1,2,3,4);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
NPM과 모듈

NPM이란?
Node Package Manager
Node.js 프로젝트를 관리하는 필수적인 도구
온라인 저장소 + 커맨드라인 도구


---NPM 온라인 저장소---
수많은 오픈소스 라이브러리와 도구들이 업로드되는 저장소
필요한 라이브러리나 도구를 손쉽게 검색 가능
Node.js의 인기로, 거대한 생태계를 보유


---커맨드라인 도구---
프로젝트 관리를 위한 다양한 명령어를 제공
- 저장소에서 라이브러리, 도구 설치
- 프로젝트 설정 / 관리
- 프로젝트 의존성 관리
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
다음중 npm의 구성요소가 아닌 것은?
온라인 저장소
프로젝트 형상 관리 ㅇ
커맨드라인 툴
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
NPM 사용해 보기
NPM 커맨드라인 도구의 사용법을 익히는 것
프로젝트의 생성부터 다양한 기능을 사용하는 법까지 학습

---프로젝트 생성하기---

$npm init
프로젝트 디렉터리를 생성하고,
해당 디렉터리 안에서 npm init 명령어를 사용하면
몇 번의 질문을 통해 package.json이라는 파일을 만들어 주고
이 디렉터리는 Node.js 프로젝트가 됨


프로젝트 생성하기
npm.init

$ npm init

package name: (first-projcet)
version: (1.0.0)
description:
entry point: (index.js)
test command:
git repository:
keywords:
author:
license: (ISC)
About to write to ~/package.json:


{
  "name": "first-project",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {},
  "author": "",
  "licnese": "ISC"
}

Is this OK? (yes)



---package.jason---
프로젝트 관련 정보들이 저장되는 파일
이 파일을 직접 수정하거나 npm 명령어를 사용하여 
프로젝트 정보를 수정할 수 있음

key                         value
version                     프로젝트의 버전
name                       프로젝트의 이름
description                프로젝트 설명
scripts                      npm run [script name]으로 실행할 수 있는 사용자 작성 스크립트
dependencies             의존성 패키지들
devDependencies        개발환경에서만 사용하는 의존성 패키지들

package.json의 구성요소


---의존성 관리하기---
프로젝트 내에서 사용하는 라이브러리를 관리하는 방법
프로젝트가 실행되기 위해 라이브러리에 의존하기 때문에
이러한 라이브러리들을 dependency(의존성)라고 이야기함


라이브러리란?
특정 기능을 수행하는 코드의 묶음
복잡한 기능을 직접 작성하지 않고, 다른 사람이 구현한 것을 사용하는 방법
Node.js 에서는 패키지라고도 부름.


---npm install 명령어---
npm install 명령어를 통해 프로젝트 의존성을 관리 할 수 있음
npm install 명령어는 사용 방법에 따라 여러 용도로 사용 가능
(npm i 를 축약형으로 사용 가능)
-의존성 추가
-의존성 내려받기
-개발용 의존성 추가
-전역 패키지 추가


---프로젝트에 의존성 추가하기---
$npm install [pacakge-name]

필요한 패키지를 프로젝트에 추가할 수 있음
추가된 패키지는 package.json의 dependencies 안에 추가되며,
node_modules 디렉터리에 저장됨.


---dependencies와 devDependencies---
$npm install [package-name] --save-dev

npm은 개발용 의존성을 분리하여 관리할 수 있음
개발용 의존성이란 배포 전까지만 사용하는 의존성 (ex. 유닛 테스트 라이브러리)
--save-dev 옵션을 이용하면 개발용 의존성을 추가할 수 있음
개발용 의존성은 package.json의 devDependencies에 추가됨.


---package-lock.json---
프로젝트에 의존성을 추가하면 package-lock.json이라는 파일이 생성됨
프로젝트에 의존성을 추가하면 자동으로 '^최신버전'으로 추가가 되는데,
의존성 버전이 갑자기 변경되지 않도록, 설치된 버전을 고정하는 역할을 함


---의존성 버전 표기법 ---
npm install [package-name]@[version] 으로 패키지 버전을 지정할 수 있음

Ex)
~1.13.0 - 1.13.x 버전 설치
^1.13.0 - 1.x.x 버전 설치, 가장 왼쪽의 0이 아닌 버전을 고정
0.13.0 - 0.13.0 버전만 설치


---프로젝트에 의존성 내려받기---
$npm install

기본적으로 node_modules 디렉터리는 코드 관리나 배포 시에 업로드 하지 않음
의존성이 많아지면 용량이 너무 커지는 것과,
운영체제별로 실행되는 코드가 다른 경우가 존재하기 때문

npm install 명령어를 아무 옵션 없이 사용하면
package.json 에 정의된 dependencies와 devDependencies의 의존성을
node_modules 디렉터리에 내려받음


---개발용 의존성을 제외하고 내려받기---
$npm install--production

프로젝트를 배포할 때에는 개발용 의존성을 같이 포함할 필요가 없음
package.json의 dependencies만 node_modules에 내려받음


---전역 패키지 추가--
$npm install [package-name] --global

패키지를 전역 패키지 디렉터리에 내려받음
주로 프로젝트에 종속되지 않는 커맨드라인 도구들을 전역 패키지로 추가해서 사용
Ex) express-generator, pm2


--- 로컬 패키지와 전역 패키지 ---

로컬 패키지
pakcage.json 에 선언되어 있고 node_modules에 저장된 패키지

전역 패키지
npm install -g 를 통해 내려받아, 전역 패키지 저장소에 저장된 패키지

전역 패키지도 프로젝트에서 사용할 수 있으나,
프로젝트의 의존성이 package.json 내에 명시적으로 선언되어 있는 것이
프로젝트 관리의 좋은 방향


--- 의존성 삭제하기 ---
$npm remove [package.json-name]

의존성 패키지를 삭제할 수 있음
package.json의 dependencies와 devDependencies에서 삭제하고
node_modules에서도 삭제


--- 스크립트 실행하기 ---
스크립트란 간단한 동작을 수행하는 코드
package.json의 scripts에 선언된 스크립트를
npm run [script-name] 명령어로 실행할 수 있음


---스크립트 실행하기---
$ npm run say-hi
"hi"



--- npm script를 사용하는 이유
npm script 내에선 의존성 패키지를 사용할 수 있음

"scripts"L{"test":"node_modules/bin/tap_test^*.js"}
전

"scripts":{"test":"tap test^.js"}
후


---자주 사용되는 스크립트---
npm 스크립트엔 run을 제외하고 사용할 수 있는 주요 스크립트들이 있음

test- 코드 유닛 테스트 등에 사용
start- 프로젝트 실행
stop- 프로젝트 종료

run을 제외하고 사용할 수 있을 뿐, npm 내부적으로 코드를 제공해 주는 것은 아님


---NPM 요약---
<명령어>
npm init - 프로젝트 생성
npm install - 의존성 추가
npm remove - 의존성 삭제
npm run - 스크립트 실행

<주요 파일/디렉터리>
node_modules - 프로젝트 의존성 저장 디렉터리
package.json - 프로젝트 관리 (버전, 의존성, 스크립트, ...)
package-lock.json - 의존성 버전 확인
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
npm init 사용하기
npm init 명령어를 사용해 봅니다.


지시사항
실행 버튼을 클릭한 후 터미널 탭으로 이동합니다.
실행 중인 npm init을 다음 지시사항에 따라 설정합니다.
프로젝트 설정은 다음과 같이 지정합니다.
package name을 myapp으로 설정합니다.
version을 0.0.1로 설정합니다.
description을 my first app으로 설정합니다.
이후 다른 설정값은 기본 값을 사용합니다. Enter 키를 입력하면 기본 값이 자동으로 입력됩니다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
NPX

NPX 란?
npm 패키지를 설치하지 않고 사용할 수 있게 해주는 도구
프로젝트에 추가하거나 전역 패키지로 추가하지 않고,
npx를 이용하여 바로 실행할 수 있음


---NPX- Node.js 특정 버전으로 실행---

$ npx node@12 index.js
$ npx node@14 index.js

npx 를 사용하면 Node.js의 특정 버전을 사용하여 js 파일을 실행할 수 있음
프로젝트의 Node.js 버전 별 실행환경을 확인할 때 유용


---NPX - github gist 코드 실행---

$ npx https://gist.github.com/zkat/4bc19503fe9e9309e2bfaa2c58074d32

gist는 github에 등록된 간단한 코드
npx를 이용하면 gist 코드를 다운받지 않고 바로 실행 가능

git이 설치되어 있어야 함(버전 관리)
온라인상의 코드는 어떤 위험이 있을지 모르므로 코드를 잘 확인하고 실행해야 함
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Node.js의 모듈

간단한 프로그램이라면 파일 하나로도 가능
프로젝트가 커지면 기능에 맞게 코드를 분리하는 것이 중요
모듈은 코드를 분리하기 위한 방법


---모듈 사용 예---
반복되는 B라는 코드를 모듈로 분리하여 사용


---모듈과 패키지---
패키지는 모듈의 모음
npm 패키지들은 많은 모듈을 포함하고 있는 코드 모음

--- Node.js의 기본 제공 모듈 ---
Node.js는 다양한 모듈을 기본적으로 제공함
기본 제공 모듈은 직접 작성하기 매우 어렵거나
복잡한 로직을 포함한 모듈이 있으므로
자주 사용되는 기본 제공 모듈을 학습해야 함


---Node.js의 기본 제공 모듈 - console---
브라우저에 제공되는 console과 유사한 디버깅 도구
log, warn, error 함수로 로그 레벨 표시
time, timeLog, timeEnd 함수로 시간 추적

---Node.js의 기본 제공 모듈 - process---
현재 실행프로세스 관련 기능 제공
arch, argv, env 등 실행 환경 및 변수 관련 값 제공
abort, kill, exit 등 프로세스 동작 관련 함수 제공


--- Node.js의 기본 제공 모듈 -fs ---
파일 입출력을 하기 위해 사용
readFile, writeFile 함수로 파일 읽기, 쓰기
-Sync 함수 제공, 동기 동작
watch로 파일/디렉터리 변경 이벤트 감지


--- Node.js의 기본 제공 모듈 - http ---
http 서버, 클라이언트를 위해 사용
createServer 함수로 서버 생성
Request 함수로 http 요청 생성


--- 기타 기본제공 모듈 ---
url - url 파싱
os - 운영체제 정보 - cpu, memory, type ...
Path - 디렉터리 string 관련 작업 - 서로 다른 운영체제 간 공통된 로직
crypto - 암호화, hash 관련 함수 제공

https://nodeks,org/dist/latest-v14.x/docs/api/
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
다음 중 Node.js의 모듈에 대한 설명으로 올바르지 않은 것은?
모듈은 코드를 분리하기 위해 사용한다.
모듈을 사용하여 코드를 재사용 할 수 있다.
Node.js 는 다양한 모듈을 기본적으로 제공한다.
패키지의 모음을 모듈이라고 한다. ㅇ
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
모듈의 작성과 사용

---모듈의 기본적인 작성법---

// elice.js
const name='elice';
const age=5;
const nationality='korea';

module.exports = {
       name,
       age,
       nationality,
};

...
const student = require('./elice');
// student 출력값 {name, 'elice', age:5, nationality:'korea'}


--- 모듈의 기본적인 작성법 ---
module.exports = {
     name,
      age,
      nationality,
};


모듈이 load 될 때 사용될 값을 module.exports로 내보냄.


--- 변수명으로 export 하는 모듈 작성법 ---

//elice.js
const name='elice';
const age=5;
const nationality='korea';

exports.name=name;
exports.age=age;
exports.nationality=nationality;

...
const student = require('./elice');
// student 출력값 {name, 'elice', age:5, nationality:'korea'}



--- 변수명으로 export 하는 모듈 작성법 ---

exports.name=name;
exports.age=age;
exports.nationality=nationality;

모듈을 object로 만들고, 각 key-value를 지정해서 내보냄


---함수를 export하는 모듈 작성법---
//elice.js
module.exports = (name, age, nationality)=>{
  return{
       name,
       age,
       naitionality,
   };
}

...
const student = require('./'elice')('elice', 5, 'korea');
// student 출력값 {name, 'elice', age:5, nationality:'korea'}



---함수를 export하는 모듈 작성법---
//elice.js
module.exports = (name, age, nationality)=>{
  return{
       name,
       age,
       naitionality,
   };
}


모듈을 함수로 만들어서 모듈 사용 시에 값을 정할 수 있게 내보냄



--- 모듈의 사용 방법 ---
require 함수를 통해 모듈을 load 할 수 있음
C에서 include, Java에서 import와 유사
의존성 패키지, 직접 작성한 모듈 사용 가능

--- 모듈의 사용 방법 - require 동작의 이해 ---
require 할 때 모듈 코드가 실행됨
Node.js의 모듈은 첫 require 시에 cache, 두 번 실행하지 않음
모듈 코드를 여러 번 실행하기 위해선 함수 모듈로 작성


--- 모듈의 사용 방법 -npm 패키지 ---
const dayjs = require('dayjs');
console.log(dayjs());

의존성 패키지들은 require('package-name')로 load 할 수 있음
패키지를 사용하려면 node_modules에 내려받아져 있어야 함


--- 모듈의 사용 방법 - 직접 작성한 모듈 ---
const myModule = require('./my-module');
console.log(myModule);

직접 작성한 모듈은 현재 파일과의 상대 디렉터리로 load
my-module이 .js 파일인 경우 해당 파일 load
my-module이 디렉터리인 경우 my-module/index.js 파일 load


--- 모듈의 사용 방법 - 함수형 모듈 ---
const myFunctionModule = require('./my-function-module');
console.log(myFunctionModule(name, age, nationality));

함수형 모듈은 load한 경우 모듈이 바로 실행되지 않음
필요한 시점에 load된 함수를 실행하여 모듈을 사용할 수 있음


--- 모듈의 사용 방법 -json 파일 ---
//my-data.json 을 가지고 있음
const myData = require('./my-data');
console.log(myData);

require로 json 파일도 load 가능
object로 자동파싱


---모듈의 작성과 사용 요약---
module.exports를 사용하여 모듈을 작성할 수 있음
require를 사용하여 의존성 패키지, 모듈, json 파일을 사용할 수 있음
모듈은 첫 require 시에만 실행하고 cache 되므로
여러 번 실행할 모듈은 함수형으로 작성해야 함
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
다음 중 모듈을 만들 때 사용하는 코드는?
module.exports =
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
다음 중 Node.js 에서 모듈을 사용하는 함수는?
require()
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
모듈 작성하기
다음은 사용할 때마다 숫자를 하나씩 카운트하는 모듈을 작성하고자 하는 코드입니다.


지시사항
현재 counter 모듈을 실행할 때 값이 증가하지 않는 동작을 하고 있습니다.

counter 모듈이 정상적으로 동작할 수 있도록 counter.js 파일을 올바르게 수정하고 index.js 파일에서 해당 모듈을 사용하는 부분을 올바르게 수정합니다.

counter.js에 작성된 module.exports = count += 1 이라고 작성된 코드를 호출할 때 마다 값이 1씩 증가하도록 코드를 수정합니다.
module.exports = () => {
    count += 1;
    return count; 
};
Copy
index.js에서 작성한 counter.js 모듈을 호출하는 코드를 올바르게 동작할 수 있도록 수정합니다.
console.log(counter());

---counter.js---
let count = 0;

/* 지시사항 1번 내용을 내용을 따라 코드를 수정해보세요. */
module.exports = () => {
    count += 1;
    return count; 
};


---index.js---
const counter = require('./counter');

for (let i = 0; i < 10; i++) {
    /* 지시사항 2번 내용을 따라 코드를 수정해보세요. */
    console.log(counter());
}
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Node.js와 Express.js

웹과 Express.js
---웹이란?---

사전적 의미 - World Wide Web, 인터넷상에서 동작하는 모든 서비스
일반적 의미 - 웹 브라우저로 접속해서 이용하는 서버스, 웹 사이트

본 수업에서의 웹 = 웹사이트

---웹 서비스 동작 방식 ---
웹 서비스는 기본적으로 HTTP 요청과 응답의 반복으로 이루어짐
HTTP 요청은 사용자가 어떤 데이터가 필요한지를 서버에게 알리는 역할
HTTP 응답은 HTTP 요청에 해당하는 적절한 데이터를 전달하는 역할

---웹 서비스 동작 방식---
1. 브라우저가 인터넷을 통해 HTTP 요청을 서버에 전달
2. 서버는 사용자의 HTTP 응답을 브라우저로 전송
3. 브라우저는 HTTP 응답을 사용자에게 적절한 화면으로 노출


--- HTTP 요청 예시 ---
GET/HTTP/1.1
Host:localhost:3000
User-Agent:Mozilla/5.0 (Windows NT 10.0;Win64;rv:93.0)
Accept:text/html
Accept-Language:ko-KR
Accept-Encoding:gzip,deflate
Connection:keep-alive

HTTP 요청은 사용자가 어떤 사용자가, 어떤 데이터를 필요로 하는지 등을 담고 있음


---HTTP 응답 예시---
전송된 데이터                                                       사용자가 요청한 데이터
HTTP/1.1 200 OK                                                      <html>
X-Powered-By:Express                                                <body>
Content-Type:text/html; charset=utf-8                           <h1>Hello, World!</h1>
Date:Mon, 25 Oct 2021 14:10:35 GMT                            </body>
Connection: keep-alive                                                </html>
Keep-Alive: timeout=5

HTTP 응답은 사용자가 요청한 데이터와, 어떤 데이터가 전송되는지 등을 담고 있음


---백엔드와 프론트엔드---
웹 서비스 개발에서 백엔드와 프론트엔드 라는 단어를 많이 접하게 됨
프론트엔드는 사용자가 직접 사용하게 되는 웹 페이즈를 주로 담당 = 클라이언트
백엔드는 사용자에게 보이지 않는 데이터 가공 등의 기능을 주로 담당 = 서버


--- 정적 웹과 동적 웹 ---

정적 웹 - WEB 1.0
동적 웹 - WEB 2.0

---Web 1.0---
사용자와 상호작용하지 않는 페이지 -단방향 통신
Link를 통한 페이지 이동 정도만 가능
일반적으로 변하지 않는 html 파일로 제공

---Web 2.0---
사용자와 상호작용을 함 - 양방향 통신
구글 맵, 웹 채팅, elice.io 등 사용자가 다앙한 기능을 수행할 수 있음
프론트엔드와 백엔드가 유기적으로 통신하며 동작
현대적인 웹은 대부분 동적 웹

--- 웹 서비스 동작 방식 정리 ---
웹 서비스는 HTTP 요청과 응답으로 동작함
클라이언트는 서버로 HTTP 요청을, 서버는 클라이언트로 HTTP 응답을 보냄
프론트엔드는 클라이언트를 담당, 백엔드는 서버를 담당
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
다음 중 웹 서비스의 동장방식에 대한 설명으로 올바르지 않은 것은?

1. 웹서비스는 HTTP 요청과 응답의 반복으로 이루어짐
2. HTTP 요청은 사용자가 어떤 데이터를 필요로 하는지 알리는 역할을 함
3. HTTP 응답을 통해 서버의 상태 외에 다른 데이터는 알 수 없음 ㅇ
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
웹 프레임워크

          웹                         +                프레임 워크
웹 서비스에 필요한                     
기능들을 제공해주는                    다양한 도구들의 모음



--- 웹 프레임워크를 사용하는 이유 ---
웹 서비스를 구성하기 위해서는 매우 많은 기능이 필요
이러한 기능들을 하나씩 직접 만드는 것에는 너무나 큰 비용이 발생
웹 서비스는 많은 부분이 정형화되어 있음
프레임워크를 사용하여 정형화된 부분을 간단하게 구현
필요한 부분만 집중해서 개발 할 수 있음


--- 웹 프레임워크의 기본 구성 요소 ---
웹 서비스의 정형화 된 구성을 많은 웹 프레임워크가 기본적으로 제공함
-HTTP 요청 처리
-HTTP 응답 처리
-라우팅
-HTML Templating


--- 웹 프레임워크 - HTTP 요청 처리 ---
웹 프레임워크는 HTTP 요청을 처리할 수 있음
어떤 데이터를 필요로 하는지
어떤 사용자로부터 요청이 수신되었는지 등


--- 웹 프레임워크 - HTTP 응답 처리 ---
웹 프레임워크는 HTTP 응답을 처리할 수 있음
응답 데이터가 어떤 형식인지
응답 상태가 정상적인지 등

--- 웹 프레임워크 - 라우팅 ---
웹 프레임워크는 HTTP 요청을 분기하는 방법을 제공함
HTTP 요청 URL에 해당하는 알맞은 응답의 경로를 미리 설정


--- 웹 프레임워크 - 라우팅 ---
HTTP 요청에 따라 알맞은 응답을 보내주는 경로를 설정해주는 일


--- 웹 프레임워크 - HTML Templating ---
웹 프레임워크는 응답으로 보낼 HTML을 서버에서 작성하기 위해,
HTML Template를 통해 미리 페이지의 뼈대를 작성 가능

---Node.js 의 웹 프레임워크---
Node.js 에는 다양한 웹 프레임워크가 있음

Express.js - Node.js 의 가장 유명한 웹 프레임워크 (본 강의에서 사용)
Koa.js - 현대적인 JavaScript를 적극적으로 사용하는 웹 프레임워크
Nest.js - TypeScript 를 사요하며, 고정된 구조를 제공하는 웹 프레임워크
기타 - Hapi, Sails.js, Meteor.js 등

--- 웹 프레임워크 정리 ---
웹 서비스를 빠르게 구성하기 위해 웹 프레임워크를 사용할 수 있음
웹 프레임워크는 HTTP 요청, 응답, 라우팅, HTML Templating 등의 기능을 제공함

Node.js 에도 다양한 웹 프레임워크가 있으며,
본 강의에서는 Node.js의 가장 유명한 웹 프레임워크인 Express.js를 다룸
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Express.js 시작하기

Express.js는 Node.js의 웹 프레임워크 중 가장 유명한 웹 프레임워크
필요에 따라 유연하게 구조 설정 가능
다양한 미들웨어를 통해 필요한 기능을 간단하게 추가 가능
모든 동작이 명시적으로 구성되기 때문에,
웹 프레임워크의 동작 방식을 이해하기 가장 좋은 프레임워크

---npm init 으로 시작하기---
$mkdir my-web
$cd my-web
$npm init
$npm i express

const express = require('express')
const app = express()

app.get('/', (req, res) => {
   res.send('Hello World!');
 });

app.listen(3000);

Express.js를 처음부터 작성할 수 있는 방법
직접 모든 구조를 작성해야 하기 때문에, Express.js를 처음 접하는 사용자에겐 쉽지 않음


---express-generator 사용하기---

$npm i -g express-generator
$express my-web
$cd my-web
$npm i
$npm start
 
Express.js는 express-generator 라고 하는
프로젝트 생성기를 제공함

express-generator를 사용하면
프로젝트의 기본구조를 자동으로 생성해줌

빠르게 프로젝트를 시작하기 좋은 방법

생성된 프로젝트는 npm start 로 실행 가능


---npx + express-generator 사용하기---

$npx express-generator my-web
$cd my-web
$npm i
$npm start

npx를 사용하여 express-generator를
설치하지 않고, 바로 사용 가능

express-generator는
프로젝트 생성 이후엔 사용되지 않기 때문에, 
npx를 사용하는 것도 좋은 방법
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Express.js의 구조

---기본 구조 알아보기---

<my-web>
app.js - Express.js의 가장 기본이 되는 파일, 웹 어플리케이션의 기능을 정의
bin/www - Express.js 실행 부분을 담당, 포트와 실행 오류 등을 정의
package.json - 프로젝트 의존성 및 스크립트 정의
public - 코드를 통하지 않고, 직접 제공되는 파일 디렉터리
routes - 라우팅 파일 디렉터리
views - HTML Template 디렉터리
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Express.js의 동작 방식

express-generator로 만들어진 프로젝트 디렉터리에 접근하여,
npm start 로 Express.js 프로젝트를 실행할 수 있음
localhost:3000 에 접속하여 Welcome to Express 페이지를 확인할 수 있음


---Express.js 동작 따라가기---
1. 브라우저에서 localhost:3000 접속
2. app.js -> app.use('/',indexRouter);
3. routes/index.js -> router.get('/', ...
4. routes/index.js -> res.render('index',...
5. views/index.jade


--app.js--
var express = require('express');
...
var app = express();


app.js에서는 express()로 생성되는 app
객체를 확인할 수 있음

app 객체는 Express.js 의 기능을 담은 객체

Express.js의 모든 동작은 app 객체에 정의됨


---app 객체 - 주요기능---

app.use() - middleware 를 사용하기 위한 함수

app.listen() - http 서버를 생성해주는 함수, express-generator 를 사용하면 http.createServer를 사용하는데
                                                          app.listen 함수로 대체할 수 있음

app.locals() - app에서 사용할 공통 상수, Express.js 에선 global 변수를 선언하지 않고 이 값을 사용할 수 있음


--- 라우팅 ---
Express.js는 다양한 라우팅 방식을 제공함
크게 app 라우팅과 Express.Router를 통한 라우팅으로 나누어짐


--- app 라우팅 ---

app.get('/' , (req, res) => {                                  app 객체에 직접 get, post, put, delete 함수를
   res.send('GET /');                                           사용하여 HTTP method 로 라우팅 할 수 있음
}); 
app.post('/' , (req, res) => {                                HTTP method 함수의 첫 번째 인자가 이 라우팅을
   res.send('POST /');                                         실행할 URL
});
app.put('/' , (req, res) => {                                 마지막 인자가 이 라우팅이 실행될 때 작동하는 함수
   res.send('PUT /');
});
app.delete('/' , (req, res) => {                             all 함수를 사용하면 HTTP method에 상관없이 라우팅 가능
   res.send('DELETE /');
});
app.all('/all' , (req, res) => {
   res.send('ANY /');
});


---Express.Router---
app 라우팅을 통해서는 라우팅의 핵심인 그룹화를 지원하지 않음
Express.Router 를 통해 라우팅을 모듈화 할 수 있음


--- Express.Router 모듈 ---

const express = require('express');                            router 객체에도 app 객체처럼
const router = express.Router();                               get, put, post, delete 함수를 사용할 수 있음

router.get('/', (req, res, next) => {                             app의 함수와 동일한 동작을 하는 함수로
   res.send('respond with a resource');                       첫 번째 인자가 라우팅 될 URL이고,
});                                                                       마지막 인자가 라우팅 시 실행될 함수
                                                             
module.exports = router;                                        라우터는 일반적으로 모듈로 만들어서 사용함



--- Express.Router 사용 ---
-app.js-
const userRouter = require('./routes/users');
const app = express();

app.use('./users', userRouter);

                                                                             작성된 라우터 모듈을 app에 use 함수로
-'./routes/users.js-                                                     연결하여 사용할 수 있음
const petRouter = require('./pets');
const router = express.Router();                                   router 객체에도 하위 라우터를 use 함수로
                                                                              연결하여 사용할 수 있음
router.use(',/pets', petRouter);

module.exports = router;


--- 라우팅 - path parameter 사용 ---
Express.js 라우팅은 path parameter를 제공
path parameter를 사용하면, 주소의 일부를 변수처럼 사용할 수 있음

Ex)
/users/:id-/users/123,/users/456 등으로 접속했을 때 라우팅 적용
/messages/:from-to -/message/123-456 등으로 접속했을 때 라우팅 적용


--- Requrest Handler ---
라우팅에 적용되는 함수를 Request Handler라고 부름
HTTP 요청과 응답을 다룰 수 있는 함수로
설정된 라우팅 경로에 해당하는 요청이 들어오면 Requrest Handler 함수가 실행됨


--- Requrest Handler ---
router.get('/:id', (req, res) => {
   const id = req.params.id
   res.send('hello ${id}');
});

ㅡㅡㅡ
router 나 app의 HTTP method 함수의
가장 마지막 인자로 전달되는 함수

설정된 라우팅 경로에 해당하는 요청이
들어오면 Request Handler 함수가 실행됨

요청을 확인하고, 응답을 보내는 역할을 함


---Request Handler - Requrest 객체---
HTTP 요청 정보를 가진 객체
HTTP 요청의 path parameter, query parameter, body, header 등을 확인 가능


--- Request Handler - Request 객체의 주요 값 및 함수 ---

req.params - URL 표현 중/path/:id 에서 :id를 req.params.id 로 사용할 수 있음

req.queries - URL 표현 중/path?page=2 에서 page 부분을 req.queries.page 로 사용할 수 있음

req.body - 일반적으로 POST 요청의 요청 데이터를 담고 있음, req.body 에 요청 데이터가 저장되어 들어옴

req.get('') - HTTP Request 의 헤더 값을 가져올 수 있음, req.get('Authorication')등으로 값을 가져옴


--- Request Handler - Response 객체 ---
HTTP 응답을 처리하는 객체
HTTP 응답의 데이터를 전송하거나, 응답 상태 및 헤더를 설정할 수 있음


--- Request Handler - Response 객체의 주요 값 및 함수 ---

res.send() - text 형식의 HTTP 응답을 전송함

res.json() - json 형식의 HTTP 응답을 전송함

res.render() - HTML Template 을 사용하여 화면을 전송함

res.set() - HTTP 응답의 헤더를 설정함

res.status() - HTTP 응답의 상태 값을 설정함


--- Express.js 동작방식 정리 ---
Express.js 는 app 객체를 시작으로 모든 동작이 이루어짐
app 객체나 Express.Router를 사용하여 라우팅을 구현할 수 있음
Request Handler 를 통해 HTTP 요청과 응답을 처리할 수 있음
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
다음 중 Express.js 의 구성요소에 대한 설명으로 올바르지 않은 것은?
1. app 객체는 Express.js 의 핵심으로 모든 동작의 시작점이다.
2. router 객체로만 라우팅을 구현할 수 있다. ㅇ
3. Request 객체는 HTTP 요청을 처리한다.
4. Response 객체는 HTTP 응답을 처리한다.

해설: Express.js 에서는 app 객체와 router 객체 두 가지를 사용하여 라우팅을 구현할 수 있습니다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
path parameter 사용하기
다음은 Express.js로 구현한 간단한 서버 프로그램입니다.


지시사항
path parameter를 사용하여 메시지를 응답으로 보내는 라우팅을 완료합니다.

/say/ 뒤에 어떤 문자열이 오든지 해당 문자열을 응답으로 출력합니다.

ex)
/say/hi라는 요청이 들어오면 응답으로 “hi” 가 출력됩니다.
ㅡㅡㅡ


const express = require('express');

const app = express();

app.get('/', (req, res) => {
    res.send("OK");
});

/* 지시사항의 내용을 따라 아래 코드를 수정해보세요. */
app.get('/say/:greeting', (req, res) => {
    const { greeting } = req.params;
    res.send(greeting);
});

app.listen(8080);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Router 사용하기
다음은 Express.js 로 구현한 간단한 서버의 예제입니다.



지시사항
./routes/users.js는 get, post, put, delete 라우팅을 가진 라우터 모듈입니다.

index.js 파일을 수정하여 라우터 모듈을 app 객체에 ‘/users’ 경로로 연결합니다.

routes 디렉터리 안에 위치한 users 모듈을 불러옵니다.
const userRouter = require('./routes/users');
Copy
불러온 users 모듈을 사용하여 “/users” 경로로 연결합니다.
app.use('/users', userRouter);

Tip
app.use('/경로 이름', 라우터 객체)
ㅡㅡㅡ


const express = require('express');

/* 지시사항 1번 내용을 코드로 작성해보세요. */
const userRouter = require('./routes/users');

const app = express();

app.get('/', (req, res) => {
    res.send("OK");
});

/* 지시사항 2번 내용을 코드로 작성해보세요. */
app.use('/users', userRouter);

app.listen(8080);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
계층적 구조의 라우터 사용하기
실습2 에서 실습했던 /users 경로에 하위 라우터를 추가 해 봅니다.

현재 구현된 서버는 /users 경로에 userRouter 가 연결되어있는 형태입니다.

지시사항에 따라 계층적 구조의 라우터 사용방식을 활용하여 petsRouter 를 추가 해 봅니다.



지시사항
./routes/users.js 파일을 수정하여,

‘/users/:userId/pets’ 경로에 petsRouter 를 설정합니다.

petsRouter 는 앱객체에 연결하지 않고,
usersRouter 하위에 연결하도록 구성합니다.
pets 라우터를 users 라우터에 연결할 때, path parameter 를 사용하는 경로를 추가하여 “/users/:userId/pets” 이하의 모든 요청을 pets 라우터가 처리할 수 있도록 구성합니다.
pets 라우터는 “GET /users/:userId/pets”라는 요청에 대해 “Pets of user {userId}” 라는 문자열을 HTTP 응답으로 보내주도록 추가 합니다.
예를들어, “GET /users/15/pets” 라는 요청에 해당하는 응답은
“Pets of user 15” 가 출력되어야 합니다.
ㅡㅡㅡ

const { Router } = require('express');

const router = Router();

router.get('/', (req, res) => {
    res.send('GET /users');
});

/* /:userId/pets 경로에 petsRouter 연결 */

router.use(‘/users/:userId/pets’, petsRouter);

module.exports = router;
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Express.js의 Niddleware

---Middleware란?---
미들웨어는 Express.js 동작의 핵심
HTTP 요청과 응답 사이에서 단계별 동작을 수행해주는 함수


---Middleware 동작 원리---
Express.js의 미들웨어는 HTTP 요청ㅇ
들어온 순간부터 시작됨

미들웨어는 HTTP 요청과 응답 객체를 처리하거나, 다음 미들웨어를 실행할 수 있음

HTTP 응답이 마무리될 때까지 미들웨어 동작 사이클이 실행됨
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Middleware의 작성과 사용

---middleware 작성법---
req, res, next를 가진 함수를 작성하면 해당 함수는 미들웨어로 동작할 수 있음
-req는 HTTP 요청을 처리하는 객체
- res는 HTTP 응답을 처리하는 객체
- next는 다음 미들웨어를 실행하는 함수

---Route Handler와 middleware
Route Handler도 미들웨어의 한 종류
Route Handler는 라우팅 함수(get, post, put, delete 등)에 적용된 미들웨어
일반적인 미들웨어와는 다르게 path parameter를 사용할 수 있음

---middleware 작성법---
const logger = (req, res, next) => {                           req, res, next 를 인자로 갖는 함수를 작성하면
   console.log('Request ${req.path}');                          미들웨어가 됨
   next();
}                                                                         res, req 객체를 통해 HTTP 요청과 응답을
                                                                          처리하거나
const auth = (req, res, next) => {                              next 함수를 통해 다음 미들웨어를 호출해야 함
   if (!isAdmin(req)) {
     next(new Error('Not Authorized'));                        next() 함수가 호출되지 않으면
     return;                                                            미들웨어 사이클이 멈추기 때문에 주의
   }
   next();
}


---middleware 사용법---
middleware는 적용되는 위치에 따라서
어플리케이션 미들웨어, 라우터 미들웨어, 오류처리 미들웨어로 분류 가능
필요한 동작 방식에 따라 미들웨어를 적용할 위치를 결정


---middleware 사용법 - 어플리케이션 미들웨어---
app.use((req, res, next) => {                                            use 나 http method 함수를 사용하여
   console.log('Request ${req.path}');                                 미들웨어를 연결할 수 있음
   next();
});                                                                               미들웨어를 모든 요청에 공통적으로 적용하기
                                                                                  위한 방법
app.use(auth);
                                                                                  HTTP 요청이 들어온 순간부터 적용된
app.get('/', (req, res, next) => {                                         순서대로 동작 함
   res.send('Hello Express');
});



---middleware 사용법 - 라우터 미들웨어---
router.use(auth);                                             router 객체에 미들웨어가 적용되는 것 외에는
                                                                   어플리케이션 미들웨어와 사용 방법은 동일
router.get('/', (req, res, next) => {
   res.send('Hello Router');                                특정 경로의 라우팅에만 미들웨어를 적용하기
});                                                                 위한 방법

app.use((req, res, next) => {                              app 객체에 라우터가 적용된 이후로 순서대로
    console.log('Request ${req.path}');                  동작함
    next();
});

app.use('/admin', router);


--- middleware 사용법 - 미들웨어 서브 스택
app.use(middleware1, middleware2, ...);                                use 나 http method 함수에 여러 개의
                                                                                     미들웨어를 동시에 적용할 수 있음
app.use('/admin', auth, adminRouter);
                                                                                     주로 한 개의 경로에 특정해서 미들웨어를
app.get('/', logger, (req, res, next) => {                                  적용하기 위해 사용
   res.send('Hello Express');
});                                                                                   전달된 인자의 순서 순으로 동작


---오류처리 미들웨어---
오류처리 미들웨어는 일반적으로 가장 마지막에 위치하는 미들웨어
다른 미들웨어들과는 달리 err, req, res, next 네 가지 인자를 가지며,
앞선 미들웨어에서 next 함수에 인자가 전달되면 실행됨


app.use((req, res, next) => {                                       가장 아래 적용된 err, req, res, next를 인자로
   if (!isAdmin(req)) {                                                 갖는 함수가 오류처리 미들웨어
     next(new Error('Not Authorized'));
      return;                                                              이전에 적용된 미들웨어 중 next에 인자를
    }                                                                        넘기는 경우 중간 미들웨어들은 뛰어넘고
    next();
});                                                                           오류처리 미들웨어가 바로 실행됨

app.get('/', (req, res, next) => {
     res.send('Hello Express');
});

app.use(err, req, res, next) => {
   res.send('Error Occurred');
});



--- 함수형 middleware ---
하나의 미들웨어를 작성하고, 작동 모드를 선택하면서 사용하고 싶을 경우
미들웨어를 함수형으로 작성하여 사용할 수 있음

Ex) API별로 사용자의 권한을 다르게 제한하고 싶은 경우



const auth = (memberType) => {                                                    auth 함수는 미들웨어 함수를 반환하는
     return (req, res, next) => {                                                        함수
         if (!checkMember(req, memberType)) {
            next(new Error('member not ${memberType}'));                      auth 함수 실행 시 미들웨어의 동작이
            return;                                                                             결정되는 방식으로 작성됨
          }
           next();                                                                              일반적으로 동일한 로직에 설정값만
       }                                                                                          다르게 미들웨어를 사용하고 싶을
}                                                                                                  경우에 활용됨

app.use('/admin', auth('admin'), adminRouter);

app.use('/users', auth('member'), userRouter);



--- Middleware Libraries ---
Express.js는 다양한 미들웨어들이 이미 만들어져 라이브러리로 제공됨
유용한 미들웨어를 npm 을 통해 추가하여 사용할 수 있음
Express.js 홈페이지나 npm 온라인 저장소에서 찾아볼 수 있음

Ex) cors, multer, passport 등



---Middleware 요약---
미들웨어는 HTTP 요청과 응답 사이에서 동작하는 함수
req, res, next를 인자로 갖는 함수는 미들웨어로 동작할 수 있음
app 혹은 router 객체에 연결해서 사용 가능
next에 인자를 넘기는 경우 오류처리 미들웨어가 실행됨
미들웨어에 값을 설정하고 싶은 경우는 함수형 미들웨어로 작성 가능
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
미들웨어 작성과 사용
다음은 Express.js 로 구현된 간단한 웹 프로그램입니다.

./middlwares/set-user.js 파일은 쿼리 파라미터를 확인하여 유저를 req 객체에 저장하는 미들웨어입니다.

유저 정보는 ./data 디렉터리의 json 파일을 사용합니다.

/users?userName=alice 경로로 접근하면 alice 유저의 정보가 출력되도록 작성되어 있습니다.

지시사항에 따라 프로그램을 수정합니다.



지시사항
./middlewares/set-user.js 의 setUser 함수는 쿼리파라미터의 userName 값을 받아, users 객체에서 유저를 찾아 req 객체에 저장하는 미들웨어입니다.

setUser 미들웨어를 admins 객체에서 관리자를 찾는 모드로 사용할 수 있도록 수정합니다.

set-user.js 파일에서 미들웨어를 추가하지 않고, setUser 미들웨어를 수정하여 admin을 찾는 모드로도 동작할 수 있도록 합니다.
admin 모드로 동작하는 미들웨어는 users에 있는 유저 정보는 접근하지 못해야 합니다.
ㅡㅡㅡ

요청과 응답 예는 다음과 같습니다.

--/users 경로 요청과 응답--
GET /users?userName=alice
"USER: alice, 1"

GET /users?userName =alex
"USER: NotFound, 0"


--/admin 경로 요청과 응답--
GET /admin?userName=alex
"ADMIN: alex, 99"

GET /admin?userName=alice
"ADMIN: NotFound, 0"
ㅡㅡㅡ

const users = require('../data/users');
const admins = require('../data/admins');


const setUser = (type) => (req, res, next) => {
    const { userName } = req.query;
    
    /* 지시사항 1번의 내용을 따라 아래에 코드를 작성해보세요. */
 if (type === "admin") {
    req.user = admins[userName];
    next();
    return;
}   
    
    
    req.user = users[userName];
    next();
}

module.exports = setUser;
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
오류처리 미들웨어의 작성과 사용
다음은 Express.js 로 구현된 간단한 서버의 코드입니다.
지시사항에 따라 오류처리 미들웨어를 작성하고 적절한 위치에 사용해 봅니다.



지시사항
index.js 파일에는 “/success” 와 “/fail” 두 경로의 라우팅이 설정되어 있습니다.

“GET /success” 요청은 정상적으로 동작하지만, “GET /
fail” 요청은 hasError 미들웨어에서 오류를 next에 전달하고 있기 때문에,
Request Handler가 정상적으로 동작하지 않습니다.

오류처리 미들웨어를 추가하여 미들웨어에서 전달된 오류를 “Request failed with {error}” 형태로 응답으로 보내도록 작성합니다.
ㅡㅡㅡ

const express = require('express');

const app = express();

const hasError = (req, res, next) => {
    next("ERROR");
}

app.get('/', (req, res) => {
    res.send("OK");
});

app.get('/success', (req, res) => {
    res.send("SUCCESS");
});

app.get('/fail', hasError, (req, res) => {
    res.send("FAIL");
});

/* 지시사항 1번의 내용을 따라 아래에 코드를 작성해보세요. */

app.use((err, req, res, next) => {
    res.send(`Request failed with ${err}`);
});
app.listen(8080);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
책 미들웨어 만들기
이번 실습에서는 미들웨어를 만들어보겠습니다.
미들웨어는 HTTP 요청과 응답 사이에서 단계별 동작을 수행해주는 함수입니다.
아래 코드를 실행하면 어떤 결과가 나타날까요?

루트 페이지가 출력되고 콘솔에 "First"가 출력되지만, "Second"는 출력되지 않습니다.
따라서 루트 페이지를 출력하는 함수에 미들웨어를 적용하면, 의도했던대로 동작하는 것을 확인할 수 있습니다.

미들웨어를 이용해 ./data/books.json에 들어있는 책 데이터를 출력하는 웹 페이지를 만들어봅시다.
ㅡㅡㅡ

지시사항
./middlewares/set-book.js에서 책 데이터를 불러오고, URI에 입력된 bookNumber query에 해당하는 책 데이터를 request로 넘겨주는 미들웨어를 만드세요.
query는 "?bookNumber=1" 형태로 받습니다. 넘겨받은 숫자로 books.json에 있는 데이터를 "req.book"으로 넘겨줍니다.
./routes/books.js에서 작성된 라우터에 req.book 내에 있는 title과 author 데이터를 받아 반환하세요.
반환하는 데이터의 형태는 "BOOK: title, author"입니다.
index.js에서 set-books.js에서 작성한 미들웨어를 추가하고, “/books” 경로에 추가로 연결하세요.
ㅡㅡㅡ
-index.js-
const express = require("express");
const bookRouter = require("./routes/books");
// set-books에서 작성한 미들웨어를 추가하고, "/books" 경로에 추가로 연결하세요.
const setBook = require("./middlewares/set-book");
const app = express();

app.get("/", (req, res) => {
  res.send("root page");
});

app.use("/books", setBook, bookRouter);

app.listen(8080);
ㅡㅡㅡ
-books.js-
const { Router } = require("express");

const router = Router();

// 미들웨어에서 넘겨준 req.book에서 title, author 데이터를 받습니다.
// 해당 데이터를 "BOOK: title, author"의 형태로 반환합니다.
router.get("/", (req, res) => {
  const { title, author} = req.book
  res.send(`book: ${title}, ${author}`)
});

module.exports = router;
ㅡㅡㅡ
-set-book.js-
// books.json을 불러오세요.
const books = require('../data/books');

// 불러온 책 데이터 중 request의 query로 요청된 데이터를 넘겨주는 미들웨어를 만드세요.
// query는 "?bookNumber=1" 형태로 받습니다. 넘겨받은 숫자로 books.json에 있는 데이터를 "req.book"으로 넘겨줍니다.
const setBook = (req, res, next) => {
  const { bookNumber } = req.query;
  req.book = books[bookNumber];

  next();
};

// 생성한 모듈은 export하세요.
module.exports = setBook;
ㅡㅡㅡ
-book.json-
{
    "1": { "title": "War and Peace", "author": "Leo Tolstoy" },
    "2": { "title": "The Old Man and the Sea", "author": "Ernest Hemingway" },
    "3": { "title": "The Republic", "author": "Plato" },
    "4": { "title": "Meditations", "author": "Marcus Aurelius" },
    "5": { "title": "This Life: Secular Faith and Spiritual Freedom", "author": "Martin Hagglund" },
    "6": { "title": "Fundamental Principles of the Metaphysics of Morals", "author": "Immanuel Kant" }
}
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Express.js 와 MongoDB

REST API란?

REST + API
REST 아키텍처를 준수하는 웹 API
RESTful API라고 부르기도 함


-API란?-
Application Programming Interface
서비스나 프로그램 간에 미리 정해진 기능을 실행 할 수 있도록 하는 규약
운영체제 API, 프로그램언어 API, 웹 API 등이 있음

-REST란?-
REpresentational(중요) State Transfer
웹에서 자료를 전송하기 위한 표현 방법에 대한 아키텍처
REST를 정확하게 구현하기 위해선 많은 제한조건이 있지만,
기본적인 REST 가이드를 따르면 조금 더 좋은 구조의 API를 구성할 수 있음

-REST API 기본 가이드 - HTTP Method의 사용
REST API는 API의 동작을 HTTP method + 명사형 URL로 표현함
/posts 라는 URL은 '게시글'이라는 자원을 가리킨다고 할 때,
GET- 가져오기, POST - 새로 만들기, PUT - 수정하기, DELETE - 삭제하기 의
HTTP method와 결합하여 API 동작을 정의하여야 함


-REST API 기본 가이드 - URL 표현법-
REST API URL의 자원은 복수형으로 표현되며,
하나의 자원에 대한 접근은 복수형 + 아이디를 통해 특정 자원에 접근함
/posts 는 '게시글 전체'를 칭하는 URL이라고 할 때,
/posts/1 은 '1번 게시글'이라는 자원을 표현함


- REST API 기본 가이드 - 계층적 자원 -
REST API는 URL을 통해 자원을 계층적으로 표현함
/users/1/posts 라는 URL은 '1번 유저의 게시글 전체'라는 지원을 나타냄


-REST API 정리-
REST API는 REST 아키텍처를 준수하는 웹 API를 의미하며,
URL을 통한 자원의 표현 방법과, HTTP method를 통한 API 동작의 정의 정도만
사용해도 훌륭한 REST API를 구현할 수 있음
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
다음 설명 중 REST API 가이드에 맞지 않는 것은?

1. HTTP Method와 URL을 합쳐 API의 동작을 정의한다.
2. URL의 자원은 단수형으로 표현한다. ㅇ
3. 자원은 계층적으로 표현한다.

해설: REST API의 URL 자원은 복수형으로 표현하는 것이 기본이며, 
특정 자원에 대한 접근은 복수형 + 아이디를 통해 접근합니다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
JSON 이론

JSON이란?
JavaScript Object Notation
자바스크립트에서 객체를 표현하는 표현식으로 시작함
데이터를 표현하는 방법이 단순하고 이해하기 쉬워서
웹 API에서 데이터를 전송할 때 표현식으로 주로 사용됨

-JSON을 사용하는 이유-
웹 API는 기본적으로 데이터를 문자열로 전송하게 됨
어떤 객체를 웹 API를 통해서 문자열로 전달하기 위해 JSON을 사용함

-JSON vs XML-

-json
[
   { name : 'cat' , legs: 4 },
   { name : 'chicken', legs: 2 },
]



-xml
<array>
   <item>
      <name>cat</name>
   </item>
      <name>chicken</name>
      <legs>2</legs>
   </item>
</array>

JSON이 더욱 적은 표현식을 사용하여 데이터를 효과적으로 표현함



---JSON 가이드 - Object---
JSON에서 Object는 {key:value}로 표현함
value에는 어떤 값이라도 사용될 수 있음 (문자열, 숫자, JSON 객체 등)

Ex) {name: 'elice', age: 5, nationality: 'korea'}



---JSON 가이드 - Array---
JSON에서 Array는 [item1, item2]로 표현함
item에는 어떤 값이라도 사용될 수 있음 (문자열, 숫자, JSON 객체 등)

Ex) ['first', 10, {name: 'bob'}]
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
다음 중 JSON의 특징에 대한 설명으로 올바르지 않은 것은?

1. JSON은 JavaScript에서 Object를 표현하는 표현식이다.
2. 통신 오버헤드가 xml에 비해 크다. ㅇ
3. 웹 API에서 데이터를 전송할 때 주로 사용한다.

해설: JSON은 통신 오버헤드가 매우 작은 표현 방법입니다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
다음 JSON 표현식에 대한 설명으로 올바른 것을 모두 고르시오.
[{
    "name": "elice",
    "languages": ["ko", "en", "jp"],
}]
ㅡㅡㅡ

1. 가장 바깥쪽은 배열이다. ㅇ

2. 가장 바깥쪽은 객체이다.

3. languages는 배열이다. ㅇ

4. languages는 객체이다.

5. languages는 문자열이다.

해설: 가장 바깥쪽과 languages 모두 []로 묶여 있어 배열임을 알 수 있습니다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Express.js로 REST API 구현하기

-목표-
데이터베이스 없이 Node.js 모듈 활용
간단한 메모의 작성, 수정, 삭제, 확인기능 API 구현
express-generator를 사용하지 않고 MVC 패턴 구현


-MVC 패턴-
MVC 패턴은 웹 서비스의 가장 대표적인 프로젝트 구성 패턴으로
프로젝트의 기능들을 어떻게 분리할지에 대한 하나의 구성 방법
Model - View - Controller를 구분하여 프로젝트 구조를 구성하는 것


-MVC 패턴 - Model-
Model은 데이터에 접근하는 기능 또는 데이터 그 자체를 의미함
데이터의 읽기, 쓰기는 Model을 통해서만 이루어지도록 구성해야 함


-MVC 패턴 - View-
View는 데이터를 표현하는 기능을 의미함
주로 Controller에 의해 데이터를 전달받고
전달받은 데이터를 화면에 표시해주는 기능을 담당

-MVC 패턴 - Controller-
Controller는 Model을 통해 데이터에 접근하여,
처리 결과를 View로 전달하는 기능을 의미함
웹 서비스에선 주로 라우팅 함수가 해당 기능을 수행함


-Express.js로 MVC 패턴 구현하기-
Node.js의 모듈화를 이용하여 MVC 패턴을 구현할 수 있음
JSON API를 구현하는 경우,
Node.js는 기본적으로 JSON을 처리하는 방법을 가지고 있기 때문에
View는 생략될 수 있음


- 프로젝트 구현 사항-
JavaScript의 Array 함수 사용하여 데이터 처리 구현
router와 route handler를 사용하여 HTTP 요청, 응답 처리 구현
오류처리 미들웨어를 사용하여, 오류를 처리하는 방법 구현
정의되지 않은 라우팅에 대해 404 오류 처리 구현

- 메모 목록 구현하기 - 

<models/note.js>
let notes = [
 {
   id: 1,
   title: 'first note',
   content: 'My first note is here.'
  }
];

exports.list = () => {
   return notes.map(({ id, title }) => ({
     id,
     title,
   }));
}


<routes/notes.js>
const { Router }= require('express');
const Note = require('../models/note');

const router = Router();

router.get('/', (req, res, next) => {
     const notes = Note.list();
     res.json(notes)
});



- 메모 상세 구현하기 - 
<models/note.js>
exports.get = (id) => {
   const note = notes.find(
     (note) => note.id === id
   );

   if (!note) {
     throw new Error('Note not found');
   }
   return note;
}



<routes/notes.js>
router.get('/:id', (req, res, next) => {
     const id = Number(req.params.id);

     try {
         const note = Note.get(id);
         res.json(note);
     } catch (e) {
       next(e);
     }
});



- 메모 작성 구현하기 - 
<models/note.js>
exports.create = (title, content) => {
     const { id: lastId } =
      note[notes.length -1];
     const newNote = {
         id: lastId + 1,
         title,
         content,
     };
     notes.push(newNote);
     return newNote;
}


<routes/notes.js>
router.post('/', (req, res, next) => {
     const { title, content } = req.body;
     const note = Note.create(title, content);
     res.json(note);
});



- 메모 수정 구현하기 -
<models/note.js>
exports.update = (id, title, content) => {
   const index = notes.findIndex(
     (note) => note.id === id
   );

   if (index < 0) {
     throw new Error('Note not found for update');
   }
   const note = notes[index];
   note.title = title;
   note.content = content;
   notes[index] = note;
   return note;
}



<routes/notes.js>
router.put('/:id', (req, res, next) => {
   const id = Number(req.params.id);
   const { title, content } = req.body;

   try {
     const note =
        Note.update(id, title, content);
     res.json(note)
    } catch (e) {
      next(e);
    }
});


- 메모 삭제 구현하기 -
<models/note.js>
exports.delete = (id) => {
   if (!notes.some((note) => note.id === id)) {
      throw new Error(
       'Note not found for delete'
      );
   }

   notes = notes.filter(note => note.id !== id);

   return;
}



<routes/notes.js>
router.delete('/:id, (req, res, next) => {
   const id = Number(req.params.id);

   try {
     Note.delete(id);
     res.json({ result: 'success' });
   } catch (e) {
     next(e);
   }
});


--- JSON 데이터 처리 미들웨어 사용하기 ---

app.use(express.json());
ㅡㅡㅡ

express.js 는 기본적으로 HTTP body에
전달되는 JSON 데이터를 처리하지 못함

express에서 기본적으로 제공해 주는
express.json() 미들웨어를 사용해야
JSON 데이터를 사용할 수 있음


--- 오류 처리 미들웨어 구현하기 ---
app.use((err, req, res, next) => {
  res.status(500);

  res.json({
     result: 'fail',
     error: err.message,
  });
});
ㅡㅡㅡ
가장 마지막 미들웨어로 오류 처리 미들웨어를 적용하면
모든 라우팅에 공통적인 오류처리 로직을 적용할 수 있음


--- 정의되지 않은 라우팅에 404 오류 처리하기 ---
app.use((req, res, next) => {
   res.status(404);
   res.send({
     result: 'fail',
     error: `page not found $(req.path}`
   });
});
ㅡㅡㅡ
모든 라우팅이 적용된 이후에 사용되는
미들웨어는 설정된 경로가 없는 요청을
처리하는 Route Handler로 동작함

Express.js 는 기본적인 404 페이지를 가지고
있지만, 직접 처리가 필요 한 경우
이와 같은 Route Handler를 추가해야 함
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
-Express.js 로 REST API 구현하기-
작성된 코드는 이번 강의에서 학습한 Express.js 로 REST API 구현하기 프로젝트와 동일한 방식으로 구현한 REST API입니다.
메모 목록과 메모 상세를 확인하는 기능이 구현되어 있으며, 메모에 작성자 값이 추가되어 있습니다.
코드를 실행하여 구현된 API를 확인해 보고, 지시사항에 따라 API를 추가해 봅니다.

1.
./routes/authors.js 라우터는 /authors 경로에 연결되어 있습니다.
“GET /authors” 요청이 들어왔을 때, 메모 작성자 목록을 json 으로 응답을 보내도록 ./routes/authors.js 에 라우팅을 추가합니다.
작성자 목록을 배열로 받는 기능은
./models/note.js 모델의 authorList 함수를 사용합니다.
ㅡㅡㅡ

const { Router } = require('express');
const Note = require('../models/note');

const router = Router();

module.exports = router;

/* 지시사항 1번의 내용을 따라 아래에 코드를 작성해보세요. */
// ./routes/authors.js에 추가 

router.get("/", (req, res, next) => {
        const notes = Note.authorList();
        res.json(notes);
});

router.get("/:author/notes", (req, res, next) => {
        const { author } = req.params;
        try {
                const notes = Note.findByAuthor(author);
                res.json(notes);
        } catch (e) {
                next(e);
        }
});
ㅡㅡㅡ

2.
./models/note.js 모듈에 author를 이용해 메모를 필터링 할 수 있는 함수 findByAuthor 를 추가합니다. 
필터링 기능은 JavaScript Array 함수 중 filter 함수를 사용합니다.
작성한 함수를 이용하여 “GET /authors/:author/notes” 요청이 들어왔을 때, 
해당 작성자의 메모를 json 으로 응답을 보내도록 ./routes/authors.js 에 라우팅을 추가합니다.
ㅡㅡㅡ
let notes = [
    {
        id: 1,
        title: '첫 메모',
        content: '애니가 작성한 첫 메모입니다.',
        author: 'annie',
    },
    {
        id: 2,
        title: '두 번째는 밥이 작성했습니다.',
        content: '안녕하세요 밥입니다.',
        author: 'bob',
    },
    {
        id: 3,
        title: '밥이 한번 더 썼습니다.',
        content: '밥이 작성한 두 번째 메모입니다.',
        author: 'bob',
    },
    {
        id: 4,
        title: '크리스도 메모를 작성했습니다.',
        content: '안녕하세요 크리스입니다.',
        author: 'chris',
    },
];

exports.list = () => {
    return notes.map(({ id, title, author }) => ({
        id,
        title,
        author,
    }));
}

exports.get = (id) => {
    const note = notes.find((note) => note.id === id);
    
    if (!note) {
        throw new Error('Note not found');
    }
    
    return note;
}

exports.authorList = () => {
    const authors = notes.map(({ author }) => author);
    return [...new Set(authors)];
}

/* 지시사항 2번의 내용을 따라 아래에 코드를 작성해보세요. */
// ./models/note.js에 추가

exports.findByAuthor = (author) => {


        const filtered = notes.filter(note => note.author === author);
        
        /* 지시사항 3번 - 오류출력 추가예정 */
        
        return filtered;
}
ㅡㅡㅡ
3.
작성자로 전체 메모를 받아오는 “GET /authors/:author/notes” 요청에 만약 작성자의 
메모가 한 개도 없다면 “:author has no note” 라는 오류를 출력하도록 구현합니다.
오류는 findByAuthor 에서 throw 되어야 하며,
오류의 출력은 index.js 에 설정된 오류처리 미들웨어를 통해 이루어지도록 구성합니다.
ㅡㅡㅡ
let notes = [
    {
        id: 1,
        title: '첫 메모',
        content: '애니가 작성한 첫 메모입니다.',
        author: 'annie',
    },
    {
        id: 2,
        title: '두 번째는 밥이 작성했습니다.',
        content: '안녕하세요 밥입니다.',
        author: 'bob',
    },
    {
        id: 3,
        title: '밥이 한번 더 썼습니다.',
        content: '밥이 작성한 두 번째 메모입니다.',
        author: 'bob',
    },
    {
        id: 4,
        title: '크리스도 메모를 작성했습니다.',
        content: '안녕하세요 크리스입니다.',
        author: 'chris',
    },
];

exports.list = () => {
    return notes.map(({ id, title, author }) => ({
        id,
        title,
        author,
    }));
}

exports.get = (id) => {
    const note = notes.find((note) => note.id === id);
    
    if (!note) {
        throw new Error('Note not found');
    }
    
    return note;
}

exports.authorList = () => {
    const authors = notes.map(({ author }) => author);
    return [...new Set(authors)];
}

/* 지시사항 2번의 내용을 따라 아래에 코드를 작성해보세요. */
// ./models/note.js에 추가

exports.findByAuthor = (author) => {


        const filtered = notes.filter(note => note.author === author);
        
        /* 지시사항 3번 - 오류출력 추가예정 */
        // findByAuthor 함수에 추가
        ...
        if (filtered.length < 1) {
                throw new Error(`${author} has no note`);
        }
        ...
        return filtered;
}
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
REST API 완성하기
작성된 코드는 이번 강의에서 학습한 Express.js 로 REST API 구현하기 프로젝트와 동일한 방식으로 구현한 코드입니다.
메모 작성자 기능이 추가되어 있으며 작성, 수정, 삭제 시에 작성자를 확인하도록 구현되어 있습니다.
지시사항에 따라 기능을 추가해봅시다.

<note.js>
let notes = [
    {
        id: 1,
        title: '첫 메모',
        content: '애니가 작성한 첫 메모입니다.',
        author: 'annie',
    },
    {
        id: 2,
        title: '두 번째는 밥이 작성했습니다.',
        content: '안녕하세요 밥입니다.',
        author: 'bob',
    },
    {
        id: 3,
        title: '밥이 한번 더 썼습니다.',
        content: '밥이 작성한 두 번째 메모입니다.',
        author: 'bob',
    },
    {
        id: 4,
        title: '크리스도 메모를 작성했습니다.',
        content: '안녕하세요 크리스입니다.',
        author: 'chris',
    },
];

exports.list = () => {
    return notes.map(({ id, title, author }) => ({
        id,
        title,
        author,
    }));
}

exports.get = (id) => {
    const note = notes.find((note) => note.id === id);
    
    if (!note) {
        throw new Error('Not not found');
    }
    
    return note;
}

exports.create = (title, content, author) => {
    const { id: lastId } = notes[notes.length - 1];
    const newNote = {
        id: lastId + 1,
        title,
        content,
        author,
    };
    
    notes.push(newNote);
    return newNote;
}

exports.update = (id, title, content, author) => {
    const index = notes.findIndex((note) => note.id === id);
    if (index < 0) {
        throw new Error('Note not found for update');
    }
    
    const note = notes[index];
    
    if (note.author !== author) {
        throw new Error("Author not matches");
    }
    
    note.title = title;
    note.content = content;
    notes[index] = note;
    return note;
}

exports.delete = (id, author) => {
    const index = notes.findIndex((note) => note.id === id);
    if (index < 0) {
        throw new Error('Note not found for delete');
    }
    const note = notes[index];
    
    if (note.author !== author) {
        throw new Error("Author not matches");
    }
    
    notes = notes.filter(note => note.id != id);
    
    return;
}

exports.search = (search) => {
    const searched = notes.filter(({ title }) => {
        const index = title.indexOf(search);
        return index >= 0;
    });
    
    return searched.map(({ id, title, author }) => ({
        id,
        title,
        author,
    }));
}
ㅡㅡㅡ
<note.js>
const { Router }  = require('express');
const Note = require('../models/note');

const router = Router();

router.get('/', (req, res, next) => {
    const { search } = req.query;
    if (search) {
        const notes = Note.search(search)
        res.json(notes)
        return;
    }
    const notes = Note.list();
    res.json(notes);
});

router.get('/:id', (req, res, next) => {
    const id = Number(req.params.id);
    try {
        const note = Note.get(id);
        res.json(note);
    } catch(e) {
        next(e);
    }
});

router.post('/', (req, res, next) => {
    const { title, content } = req.body;
    const author = req.get("author");
    const note = Note.create(title, content, author);
    res.json(note);
});

router.put('/:id', (req, res, next) => {
    const id = Number(req.params.id);
    const { title, content } = req.body;
    const author = req.get("author");
    try {
        const note = Note.update(id, title, content, author);
        res.json(note);
    } catch(e) {
        next(e);
    }
});

router.delete('/:id', (req, res, next) => {
    const id = Number(req.params.id);
    const author = req.get("author");
    try {
        Note.delete(id, author);
        res.json({
            result: "success",
        });
    } catch(e) {
        next(e);
    }
});

module.exports = router;
ㅡㅡㅡ
<auth.js>
module.exports = (req, res, next) => {
    const author = req.get("author");
    
    if (!author) {
        next(new Error("No Author"));
        return;
    }
    
    // admin 확인하기
    if ()author == "admin") {
        const password = req.get("password");
        if (password !== "1234") {
            next(new Error('Invalid Admin Password'));
            return
        }
    }
    next();
}
ㅡㅡㅡ
<index.js>
const express = require('express');
const auth = require('./middlewares/auth');
const noteRouter = require('./routes/notes');

const app = express();

app.use(express.json());

app.get('/', (req, res) => {
    res.send('OK');
});

app.use('/notes', auth, noteRouter);

app.use((req, res, next) => {
    res.status(404);
    res.json({
        result: 'fail',
        error: `Page not found ${req.path}`,
    });
});

app.use((err, req, res, next) => {
    res.status(500);
    res.json({
        result: 'fail',
        error: err.message,
    });
});

app.listen(8080);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
MonggoDB

MongoDB와 Mongoose

-MonggoDB란?-
대표적인 NoSQL, Document DB
Mongo 는 Humongous 에서 따온 말로, 엄청나게 큰 DB 라는 의미
-> 대용량 데이터를 처리하기 좋게 만들어짐


-RDB와 NoSQL-
NoSQL vs RDB(Relational DB) => SQL

-RDB 와 NoSQL-
Relational Database

관계형 데이터베이스
자료들의 관계를 주요하게 다룸.
SQL 질의어를 사용하기 위해 데이터를 구조화해야 함 (구조화 및 정형화)

Non SQL 또는 Not Only SQL
구조화된 질의어를 사용하지 않는 데이터베이스
자료 간의 관계에 초점을 두지 않음
데이터를 구조화하지 않고, 유연하게 저장함


- NoSQL을 사용하는 이유 -
SQL을 사용하기 위해서는 데이터를 구조화하는 것이 필수 (DDL)
-> 스키마에 정의된 데이터가 아니면 저장할 수 없는 제약이 따름

NoSQL을 사용하면 사전작업 없이 데이터베이스를 사용할 수 있음
-> 데이터베이스 작업에 크게 관여하지 않고 프로젝트를 빠르게 진행할 수 있음


---MySQL(RDB) vs MongoDB(NoSQL)---

<MySQL>
CREATE DATABASE simple_board

CREATE TABLE posts (
   id NOT NULL AUTO INCREAMENT
   title VARCHAR(30),
   content TEXT,
   PRIMARY KEY(id)
);

   INSERT INTO posts (title, content)
   VALUES
   ('first title', 'first content')
   ('second title', 'second content'),
ㅡㅡㅡ

<MySQL>
use simple_board
db.posts.insert([
   {
     title: 'first title',
     content: 'first content'
   },
   {
     title: 'second title',
     content: 'second content'
   }
]);
ㅡㅡㅡ

NoSQL과 Document DB
NoSQL은 다양한 종류가 있지만,
대표적으로 자료를 Document(문서) 로 저장하는 Document DB가 일반적
이 외에, key-value, Graph, large collection 등의 NoSQLDB가 존재


-MongoDB 기본 개념-
Database > Collection > Document

-MongoDB 기본 개념 - Database
하나 이상의 collection을 가질 수 있는 저장소
SQL에서의 database와 유사


-MongoDB 기본 개념 - Collection
하나 이상의 Document가 저장되는 공간
SQL 에서의 table과 유사
하지만, collection 이 document의 구조를 정의하지 않음


-MongoDB 기본 개념 - Document
MongoDB에 저장되는 자료,
SQL에서 row와 유사하지만 구조제약 없이 유연하게 저장 가능
JSON과 유사한, BSON을 사용하여 다양한 자료형을 지원



-MongoDB 기본 개념 - Document - ObjectID
Document > ObjectID
각 document의 유일한 키 값, SQL 의 primary key와 유사
하나씩 증가하는 값이 아닌 document를 생성할 때 자동으로 생성되는 값
***** timestamp + randon value + auto increament *****


-MongoDB 사용 방법-
MongoDB를 직접 설치하거나 Cloud 서비스를 사용할 수 있음
직접 설치하면 귀찮고 어렵지만 원하는 만큼 얼마든지 데이터를 사용할 수 있음
Cloud를 사용하면 쉽고 빠르게 시작 가능하지만, 사용량에 따라 요금이 부과됨


-MongoDB 사용 방법- 직접 MongoDB 설치하기

직접 모든 데이터베이스 관련 설정을 해야 함
Sharding이나 Replication 등의 작업이 필요할 때 운영지식과 노하우가 요구됨
무료로 사용할 수 있는 Community Version을 제공 함


-MongoDB 사용 방법- MongoDB Cloud 이용하기

모든 데이터베이스 관련 기능을 웹에서 관리 가능
특별한 노하우 없이 데이터베이스 운용 가능
사용량에 따라 비용이 발생하지만, 512MB까지는 평생 무료로 사용 가능


-MongoDB 사용 방법- MongoDB Compass

MongoDB에 접속하여 Database, Collection, Document 등을
시각화하여 관리할 수 있게 도와주는 도구
MYSQL을 사용할 때 MySQL Workbench와 유사
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
다음 중 RDB와 NoSQL의 차이에 대한 설명으로 올바르지 않은 것은?

1. RDB는 SQL을 사용하기 위해 데이터를 구조화한다.

2. NoSQL은 데이터를 유연하게 저장할 수 있다.

3. NoSQL Document DB 외에 key-value, graph, large collection 등의 다양한 형태의 DB가 있다.

4. NoSQL은 데이터 구조를 정의해야 사용이 가능하다. ㅇ

해설: NoSQL은 데이터의 구조를 정의하지 않고 사용할 수 있는 장점이 있습니다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Mongoose ODM

Mongoose ODM이란?
Object Data Modeling

MongoDB의 Collection에 집중하여 관리하도록 도와주는 패키지
Collection을 모델화하여, 관련 기능들을 쉽게 사용할 수 있도록 도와줌



-Mongoose ODM을 사용하는 이유-

-연결관리:
MongoDB의 기본 Node.js 드라이버는 연결상태를 관리하기 어려움
Mongoose를 사용하면 간단하게 데이터베이스와의 연결상태를 관리해줌


-스키마 관리:
스키마를 정의하지 않고 데이터를 사용할 수 있는 것은 NoSQL의 장점이지만,
데이터 형식을 미리 정의 해야 코드 작성과 프로젝트 관리에 유용함
Mongoose는 Code-Level에서 스키마를 정의하고 관리할 수 있게 해 줌


-Polpulate:
MongoDB는 기본적으로 Join을 제공하지 않음
Join과 유사한 기능을 사용하기 위해선 arregate 라는 복잡한 쿼리를 해야 하지만,
Mongoose는 populate를 사용하여 간단하게 구현할 수 있음
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Mongoose 사용하기
다음은 Mongoose를 사용하는 예제입니다.
지시사항에 따라 주어진 코드를 완성하고 Mongoose를 사용해 봅니다.
코드 실행 시 작성된 모델을 이용하여 Document를 생성하는 간단한 테스트가 진행됩니다.


지시사항
Mongoose 사용 방법의 순서에 따라 코드를 완성합니다.

1.
PostSchema를 정의합니다.
PostSchema는 ./models/schemas/post.js 파일에 모듈로 작성합니다.

Post는 title, content 속성을 가집니다.

title은 String 타입으로 필수 속성입니다.

content 또한 String 타입으로 필수 속성입니다.

필수속성을 정의하기 위해서는 required 옵션을 사용합니다.

required 옵션의 사용 예는 다음과 같습니다.
ㅡㅡㅡ
2.
정의한 Schema를 이용하여 모델을 생성합니다.
./models/index.js 파일의 exports.Post = 뒤에 모델을 완성합니다.

모델의 이름은 'Post'로 사용합니다.

모델 생성의 예제 코드는 다음과 같습니다.
ㅡㅡㅡ
3.
작성한 코드가 정상 동작하는지 확인합니다.
실행 시 모델의 정상적인 동작을 확인하는 두 개의 코드가 실행됩니다.
첫 번째로 게시글이 정상적으로 생성되는지 확인합니다.
두 번째로 제목이 없는 게시글 작성 시 오류가 발생하는지 확인합니다.
정상적인 출력은 다음과 같습니다.
ㅡㅡㅡ
<post.js>




<index.js>
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Mongoose ODM 사용하기

-Mongoose ODM 사용 순서
1. 스키마 정의 
2. 모델 생성 
3. 데이터베이스 연결 
4. 모델 사용 


-스키마 정의하기
const { Schema } = require('mongoose');

const PostSchema = new Schema({
     title: String,
     content: String,
}, {
     timestamps: true,
}];

module.exports = PostSchema;
ㅡㅡㅡ
Collection에 저장될 Document의 스키마를
Code-Level에서 관리할 수 있도록
Schema를 작성할 수 있음

다양한 형식을 미리 지정하여,
생성, 수정 작업 시 데이터 형식을 체크해주는
기능을 제공함

timestamps 옵션을 사용하면
생성, 수정 시간을 자동으로 기록해 줌


--- 모델 만들기 ---
const mongoose = require('mongoose');

const PostSchema = require('./schemas/board');

exports.Post = mongoose.model('Post', PostSchema);
ㅡㅡㅡ
작성된 스키마를 mongoose에서
사용할 수 있는 모델로 만들어야 함

모델의 이름을 지정하여 Populate 등에서
해당 이름으로 모델을 호출할 수 있음


- 데이터베이스 연결하기 -
const mongoose = require('mongoose');

const { Post } = require('./models');

mongoose.connect('mongodb://localhost:27017/myapp')';

// Post 바로 사용 가능
ㅡㅡㅡ
connect 함수를 이용하여 간단하게
데이터베이스에 연결할 수 있음

mongoose는 자동으로 연결을 관리해 주어
직접 연결 상태를 체크하지 않아도
모델 사용 시 연결 상태를 확인하여 사용이
가능할 때 작업을 실행 함


--- 모델 사용하기 - 간단한 CRUD ---
작성 된 모델을 이용하여 CRUD를 수행할 수 있음

<CRUD>                  <함수명>
CREATE(생성)                    create

READ(읽기)                       find, findByld, findOne

UPDATE(수정)                   updateOne, updateMany, findByIdAndUpdate, findOneAndUpdate

DELETE(삭제)                    deleteOne, deleteMany, findByIdAndDelete, findOneAndDelete


---간단한 CRUD-CREATE---
const { Post } = require(',/models');                                create 함수를 사용하여 Document 생성
   
async function main() {                                                create 함수에는 Document Object나
   const created = await Post.create({                             -> 단일 Document 생성
     title: 'first title',                                                      Document Object의 Array 전달 가능
     content: 'second title',                                            -> 복수 Document 생성
   });
                                                                              create는 생성된 Document를 반환해 줌
   const multpleCreated = await Post.create([
      item1,
      item2
    ]);
   }


--- 간단한 CRUD - FIND (READ) ---
const { Post } = require(',/models');                                find 관련 함수를 사용하여
                                                                               Document를 검색
async function main() {    
     const listPost = await Post.find(query);                       query를 사용하여 검색하거나
     const onePost = await Post.findOne(query);                findById를 사용하면 ObjectID로
     const postById = await Post.findById(id);                     Document를 검색할 수 있음
}



---Query---
MongoDB에도 SQL의 where와 유사한 조건절 사용 가능
MongoDB의 query는 BSON 형식으로,
기본 문법 그대로 mongoose에서도 사용 가능

---Query - 자주 사용되는 query---

Person.find({
   name: 'kyubum',                                         { key: value } 로 exact match
   age: { 
      $lt: 20,                                                   $It, $Ite, $gt, $gte 를 사용하여
      $gte: 10,                                                range query 작성 가능 (lt <   /   lte <=  /   gt >  /  gte >=)
      },                                                
     languages: {                                            $in 을 사용하여 다중 값으로 검생
       $in: ['ko', 'en'],                       
      },                                                          $or 를 사용하여 다중 조건 검색
     Sor: [
       { status: 'ACTIVE' },
       { isFresh: true },
       ],
  });


---참고 - Mongoose ODM - $in---

Person.find( { name: [ 'elice', 'bob' ] });
// { name: { $in: ['elice', 'bob'] } }
Mongoose는 쿼리 값으로 배열이 주어지면 자동으로 $in 쿼리를 생성해 줌


---MongoDB Query Operators---
MongoDB 홈페이지에서 다양한 Query Operator들 확인 가능
https://docs.mongodb.com/manual/reference/operator/query/


---간단한 CRUD - UPDATE---

async function main() { 
     const updateResult = await Post.updateOne(query, {
     ...
    });
     const updateResults = await Post.updateMany(query, {
     ...
    });
     const postById = await Post.findByIdAndUpdate(id, {
     ...
    });
    const onePost = await Post.findOneANdUpdate(query, {
    ...
    });
 }
ㅡㅡㅡ
update 관련 함수를 사용하여
Document를 수정

find~ 함수들은 검색된 Document를
업데이트를 반영하여 반환해 줌

mongoose 의 upadate 는 기본적으로
$set operator 를 사용하여,
Document를 통째로 변경하지 않음
ㅡㅡㅡ


---간단한 CRUD - UPDATE---

async function main() {
   const deleteResult = await Post.deleteOne(query);

   const deleteResults = awiat Post.deleteMany(query);

   const onePost = await Post.findOneAndDelete(query);

   const postById = await Post.findByIdAndDelete(query);
}
ㅡㅡㅡ
delete 관련 함수를 사용하여
Document 삭제

find~ 함수들은
검색된 Document를 반환해 줌
ㅡㅡㅡ


---populate---

const Post = new Schema({
   ...
   user: {
      type: Schema.Types.ObjectId,
      ref: 'User'
     },
     comments: [{
       type: Schema.Types.ObjectId,
       ref: 'Comment',
     }],
   });

 const post = await Post
   .find().populate(['user', 'comments']);

  // post.user.name, post.comments[0].content
ㅡㅡㅡ
Document 안에 Document를 담지 않고,
ObjectID를 가지고 reference 하여 사용할 수
있는 방법을 제공 함


Document에는
reference되는 ObjectID를 담고,
사용할 때 populate하여
하위 Document처럼 사용할 수 있게 해 줌
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Mongoose ODM을 사용하는 방법을 순서대로 구성해 주세요.
Mongoose ODM을 사용하기 위한 방법들이 나열되어 있습니다.
이를 순서대로 정렬해 주세요.


모델 생성 2

데이터베이스 연결 3

스키마 정의 1

모델 사용 4
 
해설: Mongoose ODM을 사용할 때에는
스키마 작성 - 모델 생성 - 데이터베이스 연결 - 모델 사용의 순서로 사용할 수 있습니다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
MongoDB Query에 대한 설명으로 올바르지 않은 것은?

MongoDB의 쿼리는 기본적으로 $and 조건으로 연결된다.

$in을 사용하면 배열에 주어진 모든 값이 포함된 Document를 검색한다. ㅇ

$lt는 주어진 값보다 작은 값을 가진 Document를 검색한다.

{ key: value }를 사용하면 정확하게 일치하는 값을 가진 Document를 검색한다.

해설: $in을 사용하면 배열에 주어진 값 중 최소 한 개의 일치하는 값을 가진 Document를 검색합니다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Mongoose 쿼리 사용하기
이번 실습은 Post 모델을 활용하여 쿼리를 실습하는 내용입니다.
Post 모델에는 검색을 테스트하기 위한 속성이 몇 가지 추가되어 있습니다.
컬렉션에 저장된 데이터는 다음과 같습니다.
ㅡㅡㅡ

const mongoose = require('mongoose');
const { Post } = require('./models');
/* 지시사항 1번의 내용을 따라 아래 코드를 수정해보세요. */
mongoose.connect("mongodb://localhost:27017/exam_5");

async function main() {
  const posts = await Post.find({      
    author: ["andy", "bob", "kate"],
    likes: {
    $gt: 5,
    $lte: 10,
    },
    $or: [
        { category: { $exists: false } },
        { category: 'notice' },
    ]
    /* 지시사항 2번의 내용을 따라 아래에 코드를 작성해보세요. */
    
  });
  return posts;
}

main()
  .then((posts) => {
    console.log("---검색 결과---");
    console.log(posts);
    console.log("---------------");
    return;
  })
  .catch(err => {
    console.error('에러가 발생했습니다.', err)
    return;
  })
  .finally(() => {
    process.exit();
  });
ㅡㅡㅡ
mongoose.connect 에 몽고디비 커넥션 문자열을 추가하여 디비에 접속합니다.
접속 주소는 "mongodb://localhost:27017/exam_5" 입니다.
ㅡㅡㅡ
다음 조건에 해당하는 게시글을 쿼리로 검색하는 코드를 작성합니다.
작성자는 "andy", "bob", "kate" 중에 한 명입니다.
좋아요("likes") 수는 5개보다 크고, 10개보다 작거나 같습니다.
게시글 분류("category")는 없거나 "notice" 입니다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ























ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Express.js + Mongoose ODM

---Express.js에서 Mongoose ODM 사용하기---

Express.js는 프로젝트 구조를 자유롭게 구성할 수 있기 때문에
어느 부분에 Mongoose ODM을 위치시키면 좋을지
적절한 위치를 결정하는 것이 중요

--- Mongoose ODM 위치 정하기 ---
일반적으로 models 디렉터리에 Schema와 Model을 같이 위치
app 객체는 어플리케이션 시작을 의미하는 부분이므로
해당 부분에 데이터베이스 연결을 명시하는 mongoose.connect를 위치

my-web
    - app.js   -    mongoose.connect 작성
    - models
           - index.js  - mongoose.model 선언
           - schemas
                  -   -  mongoose.Schema 정의


--- Mongoose ODM 커넥션 이벤트 ---
Express.js 어플리케이션은 종료되지 않고 동작하기 때문에
계속해서 데이터베이스가 정상적으로 동작하는지를 파악하기 위해
동작 중에 발생하는 데이터베이스 연결 관련 이벤트에 대한 처리를 하는 것이 좋음

--- Mongoose ODM 커넥션 이벤트 ---

mongoose.connect('----');                                             connected - 연결 완료

mongoose.connection.on('connected', () => {                  disconnected - 연결이 끊김
});
 
mongoose.connection.on('disconnected', () => {               reconnected - 재연결 완료
});

mongoose.connection.on('reconnected', () => {                 reconnectFailed - 재연결 시도 횟수 초과
});

mongoose.connection.on('reconnectFailed', () => {
});
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Express.js + Mongoose 연결하기
강의에서 살펴 본 Express.js 와 Mongoose 연결하기 방식에 따라 구성 한 프로젝트 입니다.
함께 살펴보며 프로젝트 구조를 이해 합니다.
ㅡㅡㅡ
const express = require('express');
const mongoose = require('mongoose');

const postsRouter = require('./routes/posts');

const app = express();

mongoose.connect("mongodb://localhost:27017/exam_7");

mongoose.connection.on("connected", () => {
  console.log("Successfully connected to MongoDB");
})

app.get('/', (req, res) => {
  res.send("OK");
});

app.use('/posts', postsRouter);

app.listen(8080);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Sequelize ORM

Sequelize ORM 이란?
Object - Realtional Mapping

MySQL, PostgreSQL 등의 RDBMS를 이용하는 간단한 방법
ODM이 단순히 모델에 집중하여 관리하는 것에 반해,
ORM은 테이블 관계와 쿼리 등의 기능을 더욱 단순화하는 용도로 주로 사용
ㅡㅡㅡ

--Sequelize ORM 사용하기--
본 강의는 MongoDB에 집중하기 위해
RDB와 ORM에 대한 자세한 내용은 다루지 않음
ORM의 작성과 사용 방법의 예제코드만 함께 살펴봄
ㅡㅡㅡ

--디비 연결--
const sequelize = new Sequelize('database', 'username', 'password', {
   host: 'localhost',
   dialect: 'mysql'
});

sequelize도 연결을 관리하는 간단한 방법을 제공
mongoose가 MongoDB만 연결이 가능한 데에 반해
sequelize는 MySQL, PostgreSQL, SQLite 등 다양한 RDBMS 에 연결 가능
ㅡㅡㅡ

--스키마 작성--

const User = sequelize.define('User', {                        sequelize는 define을 통해
   name: {                                                              Schema를 생성
     type: DataTypes.STRING(10),
     allowNull: false                                                 mongoose.Schema와 유사하지만
   },
   age: {                                                                sequelize는 Schema가 DDL도 생성해 줌
     type: DataTypes.Integer,
   }
}, {});
ㅡㅡㅡ

-- 스키마 작성 - 관계 정의 --

User.hasMany(Post);                                                sequelize를 이용하면 테이블 간의 관계를
Post.belongsTo(User);                                              Code-Level로 관리할 수 있음
Foo.belongsToMany(Bar);
Bar.belongsToMany(Foo);                                         이를 이용하면 외래키 설정과 제약조건까지
                                                                           DDL로 생성해 줌

                                                                            또한 다대다 관계 설정을 통해
                                                                            relation table도 자동으로 생성해 줌
ㅡㅡㅡ

-- 쿼리 --

User.findAll({                                                          Operator를 이용해
   where: {                                                              SQL 쿼리를 코드로 작성 가능
     name: 'elice',
     age: {                                                               스키마의 관계 설정을 한 경우, include를
         [0p.lt]: 20,                                                     사용하여 자동으로 join 쿼리 생성 가능
         [0p.gte]: 10,
     },
   },
   include: User,
 });
ㅡㅡㅡ

--Synchronization--

sequelize.sync();

define된 model 데이터를 바탕으로 DDL을 자동으로 실행해 줌
-> 직접 데이터베이스에 접속하여 테이블 생성 및 관리를 할 필요가 없음
-> 자동으로 생성된 DDL을 따르지 않으면 테이블 관리가 어려워 짐
ㅡㅡㅡ

--Sequelize ORM 정리--

Sequelize ORM 을 사용하면 데이터베이스에 직접 DDL을 하지 않고
JavaScript 코드로 테이블 및 관계를 관리할 수 있음
또한 RDB의 어려운 점 중 하나인 join을 간단하게 사용할 수 있음
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
MongoDB 스키마 및 모델 구성하기
Mongoose를 이용해 데이터베이스 스키마와 모델을 구성해봅니다.

현재 index.js에서는 작성한 Mongoose 모델을 이용해 데이터를 삽입 및 출력하고 있습니다.

이에 대해 학생 정보가 올바르게 출력될 수 있도록 스키마를 만들어봅시다.
ㅡㅡㅡ
const { Schema } = require("mongoose");

/* 지시사항 1번의 내용을 따라 아래 코드를 수정해보세요. */
const StudentSchema = new Schema({
    name: {
        type: String,
        required: true,
    },
    age: {
        type: Number,
    },
    major: {
        type: String,
    },
});

module.exports = StudentSchema;
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
GET 요청을 처리하는 API 만들기
MongoDB에서 데이터를 읽어 반환해주는 GET 요청을 처리하는 API를 작성해봅니다.
현재 MongoDB에는 학생의 데이터가 담겨져있습니다.
router에서 /students 경로를 통해 GET 요청을 하여 전체 학생 정보를 출력하도록 코드를 완성해봅시다.
ㅡㅡㅡ


지시사항
routes/students.js에서 전체 학생 데이터를 GET 요청으로 받아 JSON 형태로 내보내는 코드를 작성하세요.
DB에서 데이터를 가져오기 위해서 비동기 처리를 해줘야 합니다.
ㅡㅡㅡ
const { Router } = require("express");
const { Student } = require("../models");

const router = Router();

/* 지시사항 1번의 내용을 따라 아래 코드를 수정해보세요. */
router.get("/", async (req, res) => {
    const students = await Student.find({});

    res.json(students);
});

module.exports = router;
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
POST 요청을 처리하는 API 만들기
MongoDB에서 데이터를 추가하는 POST 요청을 처리하기 위한 API를 작성해봅니다.

router에서 /students 경로를 통해 POST 요청을 하여, 
데이터베이스에 새로운 학생 정보를 등록하는 코드를 완성해봅시다.

새로운 데이터를 등록하는 페이지와 등록되어 있는 데이터를 출력하는 
페이지는 views 폴더에 pug로 구현되어 있습니다.
ㅡㅡㅡ
const { Router } = require("express");
const { Student } = require("../models");

const router = Router();

router.post("/", async (req, res) => {
  /* 지시사항 1번의 내용을 따라 아래에 코드를 작성해보세요. */
  const { name, age, major } = req.body;
  /* 지시사항 2번의 내용을 따라 아래에 코드를 작성해보세요. */
  const student = await Student.create({
    name,
    age,
    major,
});  
  /* 지시사항 3번의 내용을 따라 아래에 코드를 작성해보세요. */
  res.json(student);
});

// 학생 데이터를 등록하는 페이지를 render합니다.
router.get("/", (req, res) => {
  res.render("register");
});

module.exports = router;
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
PUT 요청을 처리하는 API 만들기
MongoDB에서 데이터를 수정하는 PUT 요청을 처리하기 위한 API를 작성해봅니다.

router에서 /students/:shortId 경로를 통해 PUT 요청을 하여, 데이터베이스에 등록된 학생 정보를 수정하는 코드를 완성해봅시다.

수정할 데이터를 선택하는 페이지(print.pug)와 수정할 데이터를 입력 받아 요청하는 페이지(edit.pug)는 views 폴더에 구현되어 있습니다.
ㅡㅡㅡ

지시사항
routes/students.js에서 PUT 요청으로 전달 받은 학생 데이터를 데이터베이스에서 찾아 수정하세요.
shortId를 가지는 데이터를 찾아 name(이름), age(나이), major(전공)을 입력 받은 데이터로 수정하세요.
비동기 처리를 해줘야 정상 동작 합니다.
ㅡㅡㅡ
const { Router } = require("express");
const { Student } = require("../models");

const router = Router();

router.put("/:shortId", async (req, res) => {
  const { shortId } = req.params;
  const { name, age, major } = req.body;
  
  /* 지시사항 1번의 내용을 따라 아래에 코드를 작성해보세요. */
  const student = await Student.updateOne({ shortId }, {
    name,
    age,
    major,
});
  
  res.status(201).send();
});


// 학생 데이터를 수정하는 페이지를 render합니다.
router.get("/:shortId", async (req, res) => {
  const { shortId } = req.params;
  const student = await Student.findOne({ shortId });
  
  res.render('edit', { student });
});

module.exports = router;
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
DELETE 요청을 처리하는 API 만들기
MongoDB에서 데이터를 삭제하는 DELETE 요청을 처리하기 위한 API를 작성해봅니다.

router에서 /students/:shortId 경로를 통해 DELETE 요청을 하여, 데이터베이스에 등록된 학생 정보를 삭제하는 코드를 완성해봅시다.

삭제 버튼은 views 폴더 내 데이터들이 출력되는 print.pug에 구현되어 있습니다.
ㅡㅡㅡ

지시사항
routes/students.js에서 DELETE 요청으로 전달 받은 학생 데이터를 데이터베이스에서 찾아 삭제하세요.

shortId를 가지는 데이터를 찾아 삭제하세요.
비동기 처리를 해줘야 정상 동작 합니다.
ㅡㅡㅡ
const { Router } = require("express");
const { Student } = require("../models");

const router = Router();

router.delete("/:shortId", async (req, res) => {
  const { shortId } = req.params;
  
  /* 지시사항 1번의 내용을 따라 아래에 코드를 추가해보세요. */
  await Student.deleteOne({ shortId });
  res.status(201).send();
});


module.exports = router;
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
특정 조건이 포함된 GET 요청을 처리하는 API 만들기
MongoDB에서 특정 조건에 해당하는 데이터를 반환하는 GET 요청을 처리하기 위한 API를 작성해봅니다.

현재 MongoDB에는 학생의 데이터가 담겨져있습니다.

router에서 /students 경로를 통해 GET 요청을 하고, URI에 입력된 조건으로 특정 학생 정보를 반환하는 코드를 완성해봅시다.
ㅡㅡㅡ


지시사항
routes/students.js에서 특정 전공(major) 을 GET 요청으로 받아, 해당 전공의 학생들만 JSON 형태로 내보내는 코드를 작성하세요.
URI에 입력되는 형태는 /students?major=전공입니다.
DB에서 데이터를 가져오기 위해서 비동기 처리를 해줘야 합니다.
ㅡㅡㅡ
const { Router } = require("express");
const { Student } = require("../models");

const router = Router();

// 지시사항을 참고하여 코드를 완성하세요.
router.get("/", async (req, res) => {
  const search_major = req.query.major;
  
  const students = await Student.find({major: search_major})
  res.json(students)
});


module.exports = router;
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Milestone 01
IT 스타트업에 새로 커리어를 시작하게 된 신입사원 연우의 첫 출근날,
함께 일하게 될 동료 A가 다음과 같이 물었습니다:
연우님, 저희가 만들고 있는 서비스의 사용자가 처음 마주하게 될 때는 어떤 정보를 보여줘야할까요?
그러자 연우가 답했습니다.
음, 그런 상황이라면 저희 서비스의 제목, 그리고 간단한 이미지가 들어가면 좋겠어요.
그러자 동료 A는 옳다꾸나 하고 맞장구를 쳤습니다.
그래요! 바로 그거에요. 그게 연우님의 첫 목표입니다.
예…? 저는 아직 저희 서비스가 어떻게 동작하는지 잘 모르는데요…?
괜찮아요. 우선 지금 있는 코드베이스를 확인하고, 간단하게 데모를 진행해봅시다. 
연우님이 어떤 사람인지 모르니까 자기소개 페이지를 만들어봐요.
코드베이스, 데모, … 낯선 말들이 향연하는 이곳에서 주어진 첫 번째 목표, 
템플릿 엔진(Template Engine) 을 활용해서 이미 있는 코드들 사이에 기능을 추가해봅시다.
ㅡㅡㅡ
지시사항
/ 경로에 에 자기 소개 페이지를 만들어주세요.

자기소개 페이지에는 다음이 포함되어야합니다:

제목(header, h1)
문단(paragraph, p)
ㅡㅡㅡ
<app.js>

const createError = require('http-errors');
const express = require('express');
const path = require('path');
const cookieParser = require('cookie-parser');
const logger = require('morgan');
const mongoose = require('mongoose');
const dayjs = require('dayjs');


/* TODO: indexRouter 연동 */ 
const indexRouter = require("./routes");

const app = express();

// view engine setup
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'pug');
app.locals.formatDate = (date) => {
  return dayjs(date).format('YYYY-MM-DD HH:mm:ss');
}

app.use(logger('dev'));
app.use(express.json());
app.use(express.urlencoded({ extended: false }));
app.use(cookieParser());
app.use(express.static(path.join(__dirname, 'public')));

/* TODO: indexRoute 연동 */ 
app.use("/", indexRouter);

// catch 404 and forward to error handler
app.use((req, res, next) => {
  next(createError(404));
});

// error handler
app.use((err, req, res, next) => {
  // set locals, only providing error in development
  res.locals.message = err.message;
  res.locals.error = req.app.get('env') === 'development' ? err : {};

  // render the error page
  res.status(err.status || 500);
  res.render('error');
});

module.exports = app;
ㅡㅡㅡ

<index.js>

/* TODO: router를 선언한 후, index를 반환하도록 해봅시다. */

const {Router} = require('express');

const router = Router()

router.get('/', (req, res) => {
    // 특정 페이지를 PUG를 이용해서 생성한다(렌더링한다).
    res.render('index')
});

module.exports = router
ㅡㅡㅡ

<index.pug>

extend layout

block content
 h1 제목
 p 내용
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
자바스크립트의 데이터 타입에 대한 다음 설명 중 틀린 설며을 고르세요.

1. 문자열(String)은 "큰따옴표" 또는 '작은따옴표' 안에 작성된 데이터를 말합니다.
2. 함수(Function)은 function 키워드를 사용해 생성할 수 있다.
3. 배열(Array)은 비슷한 성격을 갖고 있는 데이터를 하나의 변수 안에서 관리하기 위한 데이터 타입이다.
4. 불리언(Boolean)은 프로퍼티, 메서드, 데이터로 구성되어 있다. ㅇ (객체)설명
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
자바스크립트의 프로퍼티와 메서드에 대한 다음 설명 중 틀린 설명을 고르세요.

1. 문자열 객체의 n번째 문자를 추출하기 위해서는 .index(n)를 사용합니다. ㅇ
2. 배열 객체의 길이를 확인하기 위해서는 .length를 사용합니다.
3. 배열 객체의 맨 뒤의 데이터를 제거하기 위해서는 .pop()을 사용합니다.
4. Math.random() 는 임의의 숫자를 출력하는 메서드입니다.

문자열 객체 n번째 문자를 추출 - str1.charAt(0);
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

DOM이란?

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
자바스크립트 제어문
03. 자바스크립트 활용
문자열 거꾸로 출력하기
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
Node.js 시작하기

다음 중 Node.js 에대한 설명으로 올바르지 않은 것은?

1. 싱글쓰레드 기반이다.
2. 서버개발 전용 런타임이다.
3. 이벤트 기반 동작을 사용한다.
4. 비동기 동작을 기본으로 한다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
NPM과 모듈

다음 중 Node.js의 모듈에 대한 설명으로 틀린 것은?

1. Node.js는 commonjs 모듈과 ES 모듈을 지원한다.

2. Node.js 모듈은 기존 javascript의 모듈화 방식을 이용하여 개발되었다. ㅇ

3. "module.exports" ="를 이용해 모듈을 생성할 수 있다.

4. "exports.name="를 이용하면 객체형 모듈이 생성된다.


기존에는 javascript에는 모듈이 없었다.
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
불 좀 꺼줄래?
엘리스네 집에는 방이 3개가 있습니다.
여기저기 방 불을 켜고 다니는 아이들을 위해 하나의 방에 불을 켜면 다른 방 불을 꺼봅시다.
ㅡㅡㅡ

지시사항
클래스 .favorites-icon을 데이터로 갖는 변수를 만드세요.

세 개의 박스 중 한 박스를 클릭하면 해당 박스가 노란색이 되도록 on 클래스를 추가하세요.

단 하나의 박스가 노란색인 상태에서 다른 박스를 클릭하면 원래 노란색인 박스는 회색이 되도록 
on 클래스를 제거하세요.
ㅡㅡㅡ

-index.js-

const iClss = document.querySelectorAll('.favorites-icon');

function clickHandler(){
   
   for(let i = 0 ; i < iClss.length ; i++){
      iClss[i].classList.remove('on');
   }
   this.classList.add('on');
   
}

for(let i = 0 ; i < iClss.length ; i++){
   iClss[i].addEventListener('click',clickHandler);
}
ㅡㅡㅡ

-index.html-

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>자바스크립트 기초</title>

    <link rel="stylesheet" href="index.css">
</head>
<body>

    <i id="first-favorites-icon" class="favorites-icon"></i>
    <i id="second-favorites-icon" class="favorites-icon"></i>
    <i id="third-favorites-icon" class="favorites-icon"></i>
    
    <script src="index.js"></script>

</body>
</html>
ㅡㅡㅡ

-index.css-

.favorites-icon {
    display: block;
    width: 50px;
    height: 50px;
    background-color: #ccc;
    margin-bottom: 10px;
}

.on {
    background-color: yellow;
}
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
















ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ